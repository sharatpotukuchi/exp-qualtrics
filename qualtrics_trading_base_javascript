// Keep Next present (off-screen) so Qualtrics accepts navigation.
Qualtrics.SurveyEngine.addOnload(function () {
  // --- keep Next programmatically usable but invisible ---
  try {
    var nb = document.getElementById('NextButton');
    if (nb) {
      nb.style.position = 'fixed';
      nb.style.left = '-9999px';
      nb.style.top = '0';
      nb.style.opacity = '0';
      nb.style.display = 'block';
      nb.style.pointerEvents = 'auto';
      nb.disabled = false;
      nb.removeAttribute('data-runtime-disabled');
      nb.removeAttribute('aria-disabled');
      nb.removeAttribute('data-runtime-hide');
    }
  } catch (e) {}

  // --- read numeric LM fields from hidden carrier and set ED (all 36 fields) ---
  var C = document.getElementById('lmCarrier');
  function F(i) {
    return (C && C.getAttribute('data-f' + i)) || '';
  }

  var map = {
    scenario_id: F(1),
    scenario_name: F(2),
    symbol: F(3),
    prices_json: F(4),
    bid: F(5),
    ask: F(6),
    last: F(7),
    balance: F(8),
    pos_qty: F(9),
    pos_px: F(10),
    hot_condition: F(11),
    treatment_group: F(12),
    sentiment_pct: F(13),
    session_tag: F(14),
    news_head: F(15),
    news_body: F(16),
    news_img: F(17),
    anchor_target: F(18),
    fair_value: F(19),
    default_order: F(20),
    default_qty: F(21),
    p_up: F(22),
    up_ret: F(23),
    down_ret: F(24),
    timer_sec: F(25),
    bias_focus: F(26),
    allowed_sides: F(27),
    default_side: F(28),
    allow_shorting: F(29),
    commission_bps: F(30),
    slippage_bps: F(31),
    close_method: F(32),
    carry_forward: F(33),
    tick_ms: F(34),
    default_price: F(35),
    narrative: F(36)
  };

  Object.keys(map).forEach(function (k) {
    try {
      Qualtrics.SurveyEngine.setEmbeddedData(k, map[k]);
    } catch (e) {}
  });

  // quick diag
  try {
    console.log(
      '[LM→ED] id/name:',
      Qualtrics.SurveyEngine.getEmbeddedData('scenario_id'),
      Qualtrics.SurveyEngine.getEmbeddedData('scenario_name')
    );
  } catch (e) {}
});

Qualtrics.SurveyEngine.addOnReady(function () {
  var q = this;

  // ===== ED logging (always on; disable via ED debug_edlog=0) =====
  (function () {
    try {
      var WANT_LOG = '${e://Field/debug_edlog}';
      var ENABLED = WANT_LOG !== '0'; // default ON even if ED not set
      var orig = Qualtrics.SurveyEngine.setEmbeddedData;
      var inLogging = false; // Guard against infinite recursion

      Qualtrics.SurveyEngine.setEmbeddedData = function (k, v) {
        if (inLogging) {
          return orig.apply(this, arguments);
        }
        
        inLogging = true;
        try {
        window._ed = window._ed || {};
        window._ed[k] = v;
        if (ENABLED) {
          try {
            console.log('[ED]', k, '=', v);
          } catch (e) {}
        }
        return orig.apply(this, arguments);
        } finally {
          inLogging = false;
        }
      };
    } catch (e) {}
  })();

  // ===== preview flag for Survey Flow branching =====
  var IS_PREVIEW = false;
  try {
    IS_PREVIEW = /[?&]Q_CHL=preview(&|$)/.test(location.search);
    Qualtrics.SurveyEngine.setEmbeddedData('is_preview', IS_PREVIEW ? '1' : '0');
  } catch (e) {}

  // ---- session + ordering stamps (hardened v3: per-seq sessionStorage) ----
  var seqNum; // hoist for later access
  try {
    // Qualtrics loop number → numeric sequence
    var seqRaw = '${lm://CurrentLoopNumber}';
    seqNum = parseInt(String(seqRaw || '').replace(/[^\d]/g, ''), 10);
    var seqKey = isNaN(seqNum) ? 'na' : String(seqNum);

    // Write the sequence to ED for analytics
    if (!isNaN(seqNum)) {
      Qualtrics.SurveyEngine.setEmbeddedData('scenario_seq', String(seqNum));
    }

    // >>> NEW: detect last scenario and tag ED
    try {
      var totalLoopsRaw = '${lm://TotalLoops}';
      var totalLoops = parseInt(String(totalLoopsRaw || '').replace(/[^\d]/g, ''), 10);
      var IS_LAST = (!isNaN(seqNum) && !isNaN(totalLoops) && seqNum === totalLoops);
      Qualtrics.SurveyEngine.setEmbeddedData('is_last_scenario', IS_LAST ? '1' : '0');
    } catch (_) {}

    // Per-scenario, page-stable timestamp:
    var TS_KEY = 'SCEN_TS__' + seqKey;
    var tsStored = null;

    try {
      tsStored = sessionStorage.getItem(TS_KEY);
    } catch (_) {}

    var tsFinal = parseInt(tsStored || '', 10);
    if (!isFinite(tsFinal) || tsFinal <= 0) {
      tsFinal = Date.now();
      try {
        sessionStorage.setItem(TS_KEY, String(tsFinal));
      } catch (_) {}
    }

    // Also mirror to a window cache (useful if sessionStorage is blocked)
    window.__SCEN_T0S = window.__SCEN_T0S || {};
    window.__SCEN_T0S[TS_KEY] = tsFinal;

    // Publish to ED (now per-page stable, per-scenario fresh)
    Qualtrics.SurveyEngine.setEmbeddedData('scenario_ts_ms', String(tsFinal));

    // Stable session id across the whole preview/run
    var SID_KEY = 'JFE_SESSION_ID';
    var sid =
      window.__SID ||
      (function () {
        try {
          return sessionStorage.getItem(SID_KEY);
        } catch (_) {
          return null;
        }
      })() ||
      Qualtrics.SurveyEngine.getEmbeddedData('SESSION_ID');

    if (!sid || sid === 'SESSION_ID') {
      sid = 'S' + Date.now() + '-' + Math.floor(Math.random() * 1e6).toString(36);
      try {
        sessionStorage.setItem(SID_KEY, sid);
      } catch (_) {}
    }
    window.__SID = sid;
    Qualtrics.SurveyEngine.setEmbeddedData('SESSION_ID', sid);
  } catch (e) {}

  // ===== helpers =====
  function toNum(v) {
    if (v == null) {
      return null;
    }
    var s = String(v).replace(/[^\d\.\-]/g, '').replace(/(\..*)\./g, '$1');
    var n = parseFloat(s);
    return isFinite(n) ? n : null;
  }

  function coerceNum() {
    for (var i = 0; i < arguments.length; i++) {
      var n = toNum(arguments[i]);
      if (n != null) {
        return n;
      }
    }
    return null;
  }

  function isNum(n) {
    return typeof n === 'number' && isFinite(n);
  }

  function fmt(n, d) {
    return isNum(n) ? n.toFixed(d == null ? 2 : d) : '—';
  }

  function signedFmt(n, d) {
    return isNum(n) ? (n >= 0 ? '+' : '') + n.toFixed(d == null ? 2 : d) : '—';
  }

  function numPretty(x) {
    var n = parseFloat(x);
    if (isNaN(n)) return x;
    return n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function ED(k) {
    try {
      return Qualtrics.SurveyEngine.getEmbeddedData(k);
    } catch (e) {
      return '';
    }
  }

  // ===== Phase 4 Rollups: helpers & boot =====
  // Total number of loops (for finalization detection)
  var TOTAL_LOOPS = (function () {
    try {
      var raw = '${lm://TotalLoops}';
      var n = parseInt(String(raw || '').replace(/[^\d]/g, ''), 10);
      return isFinite(n) ? n : null;
    } catch (_) {
      return null;
    }
  })();

  // sessionStorage numeric helpers
  function ssGetNum(key, defVal) {
    try {
      var v = sessionStorage.getItem(key);
      if (v == null) return defVal;
      var n = parseFloat(v);
      return isFinite(n) ? n : defVal;
    } catch (_) {
      return defVal;
    }
  }
  function ssSetNum(key, num) {
    try {
      sessionStorage.setItem(key, String(isFinite(num) ? num : 0));
    } catch (_) {}
  }

  // accumulator keys
  var ACC = {
    RT_SUM: 'NUDGE_R_RT_SUM',
    N_SCEN: 'NUDGE_R_N_SCEN',
    HINT_N: 'NUDGE_R_HINT_N',
    REALIZED: 'NUDGE_R_REALIZED',
    FEES: 'NUDGE_R_FEES',
    BAL_LAST: 'NUDGE_R_BAL_LAST',
    HWM: 'NUDGE_R_BAL_HWM',
    MAX_DD: 'NUDGE_R_MAX_DD',
    MAX_DD_PCT: 'NUDGE_R_MAX_DD_PCT'
  };

  // cold boot (idempotent)
  (function rollupBoot() {
    if (!sessionStorage.getItem(ACC.N_SCEN)) {
      ssSetNum(ACC.RT_SUM, 0);
      ssSetNum(ACC.N_SCEN, 0);
      ssSetNum(ACC.HINT_N, 0);
      ssSetNum(ACC.REALIZED, 0);
      ssSetNum(ACC.FEES, 0);
      var bal0 = (function () {
        var n = toNum(jQuery('#balanceTxt').text());
        if (isNum(n)) return n;
        var edBal = toNum(ED('rolling_balance')) || toNum(ED('balance'));
        return isNum(edBal) ? edBal : 100000;
      })();
      ssSetNum(ACC.BAL_LAST, bal0);
      ssSetNum(ACC.HWM, bal0);
      ssSetNum(ACC.MAX_DD, 0);
      ssSetNum(ACC.MAX_DD_PCT, 0);
    }
  })();
  // ===== /Phase 4 Rollups =====

  // === AI Nudge: config & helpers ===
  var AI_NUDGE_ENDPOINT = ED('ai_nudge_endpoint') || 'https://YOUR_API_HOST/nudge'; // TODO: set real URL
  console.log('AI_NUDGE_ENDPOINT DEBUG: raw ED value:', ED('ai_nudge_endpoint'), 'final:', AI_NUDGE_ENDPOINT);
      var AI_NUDGE_TIMEOUT_MS = (function(){
        var raw = ED('ai_nudge_timeout_ms'); 
        var n = toNum(raw); 
        console.log('AI_NUDGE_TIMEOUT_MS: raw ED value:', raw, 'parsed:', n, 'final:', 10000); // Force 10000ms for GPT
        return 10000;  // Force 10000ms timeout for GPT responses
      })();

  // Read comprehensive participant profile from ED
  function readProfileSignals() {
    // Be permissive with ED names so we don't 404 on missing keys.
    var screener =
      ED('prolific_screener_json') || ED('prolific_json') || ED('screener_json') || '';
    var cctScore =
      toNum(ED('cct_score')) != null ? toNum(ED('cct_score')) :
      toNum(ED('cct_total')) != null ? toNum(ED('cct_total')) :
      toNum(ED('CCT_total_points')) != null ? toNum(ED('CCT_total_points')) :
      null;
    var cctBucket = ED('cct_bucket') || '';
    
    // CCT Hot/Cold scores
    var cctHotScore = toNum(ED('CCT_hot_score')) || null;
    var cctColdScore = toNum(ED('CCT_cold_score')) || null;
    var cctHotColdDiff = null;
    if (cctHotScore != null && cctColdScore != null) {
      cctHotColdDiff = cctHotScore - cctColdScore;
    }

    // Try to parse screener JSON if it looks like JSON
    try {
      if (typeof screener === 'string' && screener.trim().charAt(0) === '{') {
        screener = JSON.parse(screener);
      }
    } catch (_) { /* leave as-is */ }

    return { 
      // Legacy fields
      screener: screener, 
      cct_score: cctScore, 
      cct_bucket: cctBucket,
      cct_hot_score: cctHotScore,
      cct_cold_score: cctColdScore,
      cct_hot_cold_diff: cctHotColdDiff,
      
      // Essential Demographics
      demographics: {
        age: toNum(ED('age')),
        gender: ED('gender'),
        education: ED('education'),
        personal_income: toNum(ED('personal_income')),
        employment: ED('employment')
      },
      
      // Key Experience & Confidence
      experience: {
        trading_years: ED('trading_experience'),
        confidence: toNum(ED('confidence')),
        financial_education: ED('financial_education'),
        investment_types: ED('investment_types'),
        market_knowledge: ED('market_knowledge')
      },
      
      // Critical Psychological Traits (Moderators)
      psychological_traits: {
        regret_avoidance: toNum(ED('regret_avoidance')),
        pre_mood: ED('pre_mood'),
        pre_decision_fatigue: ED('pre_decision_fatigue')
      },
      
      // Post-Survey Reflection (Mediators/Outcomes)
      post_survey: {
        satisfaction: ED('post_satisfaction'),
        confidence: ED('post_confidence'),
        bias_awareness: ED('post_bias_awareness'),
        learning_perception: ED('post_learning_perception'),
        ai_helpfulness: ED('Post_AI_helpfulness')
      },
      
      // Key Behavioral Biases (Nudge Targets) - Placeholder for future questions
      behavioral_biases: {
        herding: toNum(ED('herding_tendency')) || null,
        anchoring: toNum(ED('anchoring_susceptibility')) || null,
        fomo: toNum(ED('fomo')) || null
      },
      
      // CCT Risk Measures (Primary)
      cct: {
        total_score: cctScore,
        hot_score: cctHotScore,
        cold_score: cctColdScore,
        hot_cold_diff: cctHotColdDiff,
        bucket: cctBucket
      }
    };
  }

  // Build payload (basic or enhanced based on feature flag)
  function buildGenericNudgePayload(execObj) {
    console.log('BUILD GENERIC PAYLOAD: Starting to build generic nudge payload');
    
    // Generic payload (scenario data only, no personalization)
    var genericPayload = {
      // Session context
      session_id: ED('SESSION_ID'),
      scenario_id: ED('scenario_id'),
      scenario_seq: ED('scenario_seq'),
      scenario_ts_ms: toNum(ED('scenario_ts_ms')),
      
      // Treatment group
      treatment_group: (ED('treatment_group') || '').toLowerCase(),
      
      // Scenario context (essentials only)
      sym: ED('symbol'),
      last: toNum(jQuery('#last').text()) || toNum(ED('last')),
      bid: toNum(jQuery('#bid').text()) || toNum(ED('bid')),
      ask: toNum(jQuery('#ask').text()) || toNum(ED('ask')),
      fair_value: toNum(ED('fair_value')),
      anchor_target: toNum(ED('anchor_target')),
      sentiment_pct: toNum(ED('sentiment_pct')),
      allowed_sides: ED('allowed_sides'),
      allow_shorting: ED('allow_shorting'),
      commission_bps: toNum(ED('commission_bps')),
      slippage_bps: toNum(ED('slippage_bps')),
      hot_condition: ED('hot_condition'),
      
      // Current order
      exec: {
        side: execObj && execObj.side,
        ordType: execObj && execObj.ordType,
        ordPx: execObj && execObj.ordPx,
        qty: execObj && execObj.qty,
        fillPx_preview: execObj && execObj.fillPx
      }
      
      // NO profile data - this is the key difference
    };
    
    console.log('BUILD GENERIC PAYLOAD: Generic payload built successfully:', genericPayload);
    return genericPayload;
  }

  function buildNudgePayload(execObj) {
    console.log('BUILD PAYLOAD: Starting to build nudge payload');
    var prof = readProfileSignals();
    var useEnhancedPayload = (ED('ai_nudge_payload_type') || 'basic').toLowerCase() === 'enhanced';
    console.log('BUILD PAYLOAD: useEnhancedPayload:', useEnhancedPayload);
    
    // Base payload (always included)
    var basePayload = {
      // who/when
      session_id: ED('SESSION_ID'),
      scenario_id: ED('scenario_id'),
      scenario_seq: ED('scenario_seq'),
      scenario_ts_ms: toNum(ED('scenario_ts_ms')),

      // treatment
      treatment_group: (ED('treatment_group') || '').toLowerCase(),

      // scenario context (just the essentials)
      sym: ED('symbol'),
      last: toNum(jQuery('#last').text()) || toNum(ED('last')),
      bid: toNum(jQuery('#bid').text()) || toNum(ED('bid')),
      ask: toNum(jQuery('#ask').text()) || toNum(ED('ask')),
      fair_value: toNum(ED('fair_value')),
      anchor_target: toNum(ED('anchor_target')),
      sentiment_pct: toNum(ED('sentiment_pct')),
      allowed_sides: ED('allowed_sides'),
      allow_shorting: ED('allow_shorting'),
      commission_bps: toNum(ED('commission_bps')),
      slippage_bps: toNum(ED('slippage_bps')),
      hot_condition: ED('hot_condition'),

      // order preview
      exec: {
        side: execObj && execObj.side,
        ordType: execObj && execObj.ordType,
        ordPx: execObj && execObj.ordPx,
        qty: execObj && execObj.qty,
        fillPx_preview: execObj && execObj.fillPx
      },

      // participant profile
      profile: prof
    };
    
    // Enhanced payload (only if feature flag is enabled)
    if (useEnhancedPayload) {
      try {
        console.log('BUILD PAYLOAD: Building enhanced payload');
        // Get current portfolio values from the global scope or calculate them
        var currentBalance = toNum(ED('balance')) || 100000;
        var currentPosQty = toNum(ED('pos_qty')) || 0;
        var currentPosPx = toNum(ED('pos_px')) || 0;
        var currentUnrealizedPL = 0; // Calculate if needed
        var currentRealizedPL = ssGetNum(ACC.REALIZED, 0);
        var currentMaxDrawdown = ssGetNum(ACC.MAX_DD, 0);
        var currentMaxDrawdownPct = ssGetNum(ACC.MAX_DD_PCT, 0);
        var currentPeakBalance = ssGetNum(ACC.HWM, 0);
        console.log('BUILD PAYLOAD: Portfolio values - balance:', currentBalance, 'posQty:', currentPosQty, 'realizedPL:', currentRealizedPL);
        
        basePayload.portfolio = {
          balance: currentBalance,
          posQty: currentPosQty,
          posPx: currentPosPx,
          unrealizedPL: currentUnrealizedPL,
          realizedPL: currentRealizedPL,
          maxDrawdown: currentMaxDrawdown,
          maxDrawdownPct: currentMaxDrawdownPct,
          totalReturn: (currentRealizedPL + currentUnrealizedPL) / currentBalance,
          tradeCount: ssGetNum(ACC.N_SCEN, 0),
          peakBalance: currentPeakBalance,
          currentDrawdown: currentPeakBalance - (currentBalance + currentUnrealizedPL),
          currentDrawdownPct: currentPeakBalance > 0 ? ((currentPeakBalance - (currentBalance + currentUnrealizedPL)) / currentPeakBalance) * 100 : 0
        };
        
        // Add scenario context for enhanced payload
        basePayload.scenario = {
          name: ED('scenario_name'),
          session_tag: ED('session_tag'),
          news_head: ED('news_head'),
          bias_focus: ED('bias_focus'),
          timer_sec: toNum(ED('timer_sec'))
        };
        
        // Add trading history context
        basePayload.trading_context = {
          scenario_start_balance: toNum(ED('balance')) || 100000,
          scenario_start_position: toNum(ED('pos_qty')) || 0,
          scenario_start_price: toNum(ED('pos_px')) || null,
          previous_trades_count: ssGetNum(ACC.N_SCEN, 0),
          previous_realized_pl: ssGetNum(ACC.REALIZED, 0)
        };
        console.log('BUILD PAYLOAD: Enhanced payload built successfully');
      } catch (error) {
        console.log('BUILD PAYLOAD: Error building enhanced payload:', error);
        // Fall back to basic payload
        useEnhancedPayload = false;
      }
    }
    
    console.log('BUILD PAYLOAD: Payload built successfully:', basePayload);
    return basePayload;
  }

  // POST with AbortController + soft fail
  function postJSON(url, data, timeoutMs, done) {
    console.log('POST JSON: Starting POST request to:', url);
    try {
      var ctrl = new AbortController();
      var actualTimeout = Math.max(200, timeoutMs||5000);
      var t = setTimeout(function(){ 
        console.log('POST: Timeout reached, aborting request after', actualTimeout, 'ms');
        try{ctrl.abort();}catch(_){ } 
      }, actualTimeout);
      var t0 = Date.now();

      console.log('POST: Making request to', url, 'timeout:', timeoutMs, 'ms', 'actualTimeout:', actualTimeout);
      fetch(url, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(data),
        signal: ctrl.signal
      })
      .then(function(res){
        return res.ok ? res.json() : Promise.reject({status:res.status});
      })
      .then(function(json){
        clearTimeout(t);
        try {
          Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_ok','1');
          Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_latency_ms', String(Date.now()-t0));
          if (json && json.model) Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_model', String(json.model));
        } catch(_){}
        done && done(null, json);
      })
          .catch(function(err){
            clearTimeout(t);
            try {
              var elapsed = Date.now() - t0;
              console.log('POST: Error after', elapsed, 'ms:', err.message, 'err.name:', err.name, 'err.code:', err.code);
              console.log('POST: Full error object:', err);
              Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_ok','0');
              Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_err', (err && (err.status||err.message)) ? String(err.status||err.message) : 'error');
              Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_err_details', JSON.stringify({
                name: err.name,
                message: err.message,
                code: err.code,
                elapsed: elapsed
              }));
            } catch(_){}
            done && done(err);
          });
    } catch (e) {
      try {
        Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_ok','0');
        Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_err','throw');
      } catch(_){}
      done && done(e);
    }
  }

  // Append AI message under existing #hint content
  function appendAiNudge(htmlFrag) {
    try {
      var $hint = jQuery('#hint');
      if (!$hint.length) return;
      var $wrap = jQuery('<div class="ai-nudge-chunk" style="margin-top:6px;padding-top:6px;border-top:1px dashed #e5e7eb;font-size:.83rem;color:#374151;"></div>');
      $wrap.html(htmlFrag);
      
      // Add instruction statement after AI nudge
      var $instruction = jQuery('<div style="margin-top:8px;padding:8px;background-color:#f8fafc;border:1px solid #e2e8f0;border-radius:4px;font-size:.85rem;color:#475569;text-align:center;"><strong>You may adjust your order or confirm and continue (above)</strong></div>');
      
      $hint.append($wrap).append($instruction).show();
    } catch(_){}
  }

  // Escape plain text -> HTML-safe
  function escapeHtml(s){
    return String(s).replace(/[<>&"']/g, function(c){
      return c === '<' ? '&lt;' : c === '>' ? '&gt;' : c === '&' ? '&amp;' : c === '"' ? '&quot;' : '&#39;';
    });
  }

  // Very small allow-list sanitizer for AI HTML
  function sanitizeAiHtml(html){
    try {
      var temp = document.createElement('div');
      temp.innerHTML = html;

      var ALLOWED_TAGS = { DIV:1, P:1, B:1, STRONG:1, I:1, EM:1, UL:1, OL:1, LI:1, SPAN:1, BR:1, SMALL:1, CODE:1 };
      var ALLOWED_ATTR = { 'class':1, 'style':1 };

      (function walk(node){
        var children = Array.prototype.slice.call(node.childNodes||[]);
        children.forEach(function(ch){
          if (ch.nodeType === 1){ // element
            if (!ALLOWED_TAGS[ch.tagName]) {
              // unwrap: move children up and remove node
              while (ch.firstChild) node.insertBefore(ch.firstChild, ch);
              node.removeChild(ch);
              return;
            }
            // strip attributes except allow-list; strip event handlers & urls
            var toRemove = [];
            for (var i=0;i<ch.attributes.length;i++){
              var a = ch.attributes[i];
              var name = (a.name||'').toLowerCase();
              var val = (a.value||'');
              if (!ALLOWED_ATTR[name]) { toRemove.push(a.name); continue; }
              if (/^on/i.test(name)) { toRemove.push(a.name); continue; }
              if (/(url|expression)\s*\(/i.test(val)) { toRemove.push(a.name); continue; }
            }
            toRemove.forEach(function(n){ ch.removeAttribute(n); });
          } else if (ch.nodeType === 3) {
            // text ok
          } else {
            node.removeChild(ch);
            return;
          }
          walk(ch);
        });
      })(temp);

      return temp.innerHTML;
    } catch(e){
      return escapeHtml(String(html||''));
    }
  }

  // ===== header-loop guard (if a header row slipped into L&M) =====
  (function () {
    var sidMaybe = ED('scenario_id');
    var pjMaybe = ED('prices_json');
    if (sidMaybe === 'scenario_id' || pjMaybe === 'prices_json') {
      console.warn('[LM] Detected header row — auto-advancing');
      try {
        var nb = document.getElementById('NextButton');
        if (nb) nb.click();
      } catch (e) {}
      return;
    }
  })();

  // ===== scenario values (ALL 36) =====
  var scenario = {
    scenario_id: ED('scenario_id'),
    scenario_name: ED('scenario_name'),
    symbol: ED('symbol'),
    prices_json: ED('prices_json'),
    bid: coerceNum(ED('bid')),
    ask: coerceNum(ED('ask')),
    last: coerceNum(ED('last')),
    balance: coerceNum(ED('balance')),
    pos_qty: parseInt(ED('pos_qty') || '0', 10) || 0,
    pos_px: ED('pos_px') || '—',
    hot_condition: ED('hot_condition') === '1',
    treatment_group: ED('treatment_group'),
    sentiment_pct: parseInt(ED('sentiment_pct') || '0', 10) || 0,
    session_tag: ED('session_tag'),
    news_head: ED('news_head'),
    news_body: ED('news_body'),
    news_img: ED('news_img'),
    anchor_target: coerceNum(ED('anchor_target')),
    fair_value: coerceNum(ED('fair_value')),
    default_order: ED('default_order') || 'Market',
    default_qty: parseInt(ED('default_qty') || '200', 10) || 200,
    p_up: coerceNum(ED('p_up')),
    up_ret: coerceNum(ED('up_ret')),
    down_ret: coerceNum(ED('down_ret')),
    timer_sec: parseInt(ED('timer_sec') || '0', 10) || 0,
    bias_focus: ED('bias_focus'),
    allowed_sides: ED('allowed_sides'),
    default_side: ED('default_side'),
    allow_shorting: ED('allow_shorting'),
    commission_bps: coerceNum(ED('commission_bps')),
    slippage_bps: coerceNum(ED('slippage_bps')),
    close_method: ED('close_method'),
    carry_forward: ED('carry_forward'),
    tick_ms: parseInt(ED('tick_ms') || '450', 10) || 450,
    default_price: ED('default_price'),
    narrative: ED('narrative')
  };

  // ===== minimal UI presence check (fixed typo) =====
  (function () {
    var NEED = [
      'scenarioName','narrative','sym','symChart','sessionTag','balanceTxt','balanceTxt_bottom',
      'lastPillTxt','last','bid','ask','posQty','posQty_bottom','posPx','sentfill','sentPct',
      'newsHead','newsBody','newsImg','targetTxt','fvTxt','fv','px','unrl','unrl_bottom'
    ];
    var missing = [];
    for (var i = 0; i < NEED.length; i++) {
      if (!document.getElementById(NEED[i])) missing.push(NEED[i]);
    }
    if (missing.length) {
      console.warn('[UI] Missing elements:', missing.join(', '));
    }
  })();

  // ===== rolling state / carry-forward =====
  var CARRY = ED('carry_forward') === '1';
  var rollingBal = toNum(ED('rolling_balance'));
  var rollingQty = parseInt(ED('rolling_pos_qty') || '', 10);
  var rollingPx = toNum(ED('rolling_pos_px'));

  // NEW: rolling session totals for fees & realized P/L
  var rollingFees = toNum(ED('rolling_fees'));
  if (rollingFees == null || !isFinite(rollingFees)) rollingFees = 0;

  var rollingRealized = toNum(ED('rolling_realized_pl'));
  if (rollingRealized == null || !isFinite(rollingRealized)) rollingRealized = 0;

  // Utility function for formatting signed numbers
  function fmtSigned(n) {
    return (n >= 0 ? '+' : '') + (isFinite(n) ? Number(n).toFixed(2) : '0.00');
  }

  // Function to update session metrics in the main panel
  function updateSessionMetrics() {
    try {
      jQuery('#realizedPL').text(fmtSigned(rollingRealized || 0));
      jQuery('#sessionFees').text(isFinite(rollingFees) ? Number(rollingFees).toFixed(2) : '0.00');
    } catch (e) {
      // Silently handle any errors
    }
  }

  // Function to update trading costs information
  function updateTradingCosts() {
    try {
      var commTxt = fmtBps(scenario.commission_bps);
      var slipTxt = fmtBps(scenario.slippage_bps);
      var sprTxt = spreadStats();
      
      var costsText = 'Commission ' + commTxt + '. ' +
                     'Slippage ' + slipTxt + ' (applied to execution price: + for Buy, - for Sell). ' +
                     'Current spread ' + sprTxt + '.';
      
      jQuery('.costs-details').text(costsText);
    } catch (e) {
      // Silently handle any errors
    }
  }

  // Helper function for formatting basis points
  function fmtBps(b) {
    return b == null || isNaN(b) ? '—' : Number(b).toFixed(0) + ' bps (' + (Number(b) / 100).toFixed(2) + '%)';
  }

  // Helper function for spread statistics
  function spreadStats() {
    var bid = toNum(jQuery('#bid').text());
    var ask = toNum(jQuery('#ask').text());
    if (!isNum(bid) || !isNum(ask) || ask <= 0 || bid <= 0 || ask <= bid) return '—';
    var spr = ask - bid;
    var mid = (ask + bid) / 2;
    var sprBps = (spr / mid) * 10000;
    return '$' + spr.toFixed(2) + ' (' + sprBps.toFixed(0) + ' bps)';
  }

  // Set up the refresh function for external calls
  window._sessMetricsRefresh = updateSessionMetrics;
  
  // Initial updates
  updateSessionMetrics();
  updateTradingCosts();
  
  // Set up periodic updates for costs (spread changes)
  var costsUpdateInterval = setInterval(function() {
    updateTradingCosts();
  }, Math.max(1200, scenario.tick_ms || 1200));

  // derive starting balance & position
  var balance0 =
    CARRY && rollingBal != null
      ? rollingBal
      : scenario.balance != null
      ? scenario.balance
      : parseFloat(jQuery('#balanceTxt').text().replace(/,/g, '')) || 100000;

  var posQty0 = CARRY && !isNaN(rollingQty) ? rollingQty || 0 : scenario.pos_qty || 0;
  var posAvg0 = CARRY && rollingPx != null ? rollingPx : toNum(scenario.pos_px);

  // ===== hydrate visible UI from ED (dynamic every loop) =====
  jQuery('#scenarioName').text(scenario.scenario_name || 'Scenario');
  jQuery('#narrative').text(scenario.narrative || ' ');
  jQuery('#sym').text(scenario.symbol || 'ALFA');
  jQuery('#symChart').text(scenario.symbol || 'ALFA');
  jQuery('#sessionTag').text(scenario.session_tag || 'Regular');
  jQuery('#balanceTxt').text(numPretty(balance0));
  jQuery('#balanceTxt_bottom').text(numPretty(balance0));
  jQuery('#posQty').text(posQty0);
  jQuery('#posQty_bottom').text(posQty0);
  jQuery('#posPx').text(posAvg0 != null && isFinite(posAvg0) ? posAvg0.toFixed(2) : '—');
  jQuery('#bid').text(fmt(scenario.bid));
  jQuery('#ask').text(fmt(scenario.ask));
  jQuery('#last').text(fmt(scenario.last));
  jQuery('#lastPillTxt').text(fmt(scenario.last));
  jQuery('#sentPct').text(scenario.sentiment_pct);
  jQuery('#sentfill').css('width', (scenario.sentiment_pct || 0) + '%');
  jQuery('#newsHead').text(scenario.news_head || ' ');
  jQuery('#newsBody').text(scenario.news_body || ' ');

  if (scenario.news_img) {
    jQuery('#newsImg').attr('src', scenario.news_img).show();
  } else {
    jQuery('#newsImg').removeAttr('src').hide();
  }

  // ensure #target exists; show anchor/fair value text blocks
  if (!document.getElementById('target')) {
    jQuery('<input>', { id: 'target', type: 'hidden' }).appendTo(document.body);
  }
  jQuery('#target').val(isNum(scenario.anchor_target) ? scenario.anchor_target : '');
  jQuery('#targetTxt').text(fmt(scenario.anchor_target));

  jQuery('#fv').val(isNum(scenario.fair_value) ? scenario.fair_value : '');
  jQuery('#fvTxt').text(fmt(scenario.fair_value));

  // defaults on ticket
  jQuery('#ordType').val(scenario.default_order || 'Market');
  jQuery('#qty').val(scenario.default_qty || 200);
  if ((scenario.default_order || 'Market') !== 'Market') {
    jQuery('#ordPx').val(scenario.default_price || '');
  } else {
    jQuery('#ordPx').val('');
  }

  function togglePx() {
    var ot = jQuery('#ordType').val();
    var $wrap = jQuery('#ordPx').closest('div');
    if ($wrap && $wrap.length) {
      ot === 'Market' ? $wrap.hide() : $wrap.show();
    }
  }
  togglePx();
  jQuery('#ordType').on('change', togglePx);

  // ===== Costs footnote — DISABLED (now integrated into main panel) =====
  (function feeFootnote_v3_DISABLED() {
    return; // Disabled - costs now shown in main panel
    // 0) Clean up any earlier attempts
    ['feeBox', 'orderFeeRow', 'feePillCSS', 'feeLabelsCSS', 'feeFootCSS', 'feeFootnote'].forEach(function (id) {
      var el = document.getElementById(id);
      if (el && el.parentNode) el.parentNode.removeChild(el);
    });

    // 1) Container: the entire question (stable) + try to match the order panel width
    var $q = jQuery('#' + q.questionId);
    if (!$q.length) return;

    var $panel = jQuery('#place').closest('.QuestionBody, .card, .panel, .q-contents, form');
    var maxW = $panel.length ? $panel.outerWidth() : 640;

    // 2) Styles (muted, footnote-y)
    if (!document.getElementById('feeFootCSS')) {
      var css = document.createElement('style');
      css.id = 'feeFootCSS';
      css.textContent = `
#feeFootnote{
  display:block;
  clear:both;
  max-width: ${Math.max(480, maxW || 640)}px;
  margin:10px auto 0 auto;
  padding:4px 0;
  font-size:.72rem;
  line-height:1.3;
  color:#6b7280;
  font-style:italic;
  border-top:1px dotted #e5e7eb;
  text-align:left;
}
#feeFootnote .k{
  color:#9ca3af;
}
`;
      document.head.appendChild(css);
    }

    // 3) Helpers
    function fmtBps(b) {
      return b == null || isNaN(b)
        ? '—'
        : Number(b).toFixed(0) + ' bps (' + (Number(b) / 100).toFixed(2) + '%)';
    }

    function spreadStats() {
      var bid = toNum(jQuery('#bid').text());
      var ask = toNum(jQuery('#ask').text());
      if (!isNum(bid) || !isNum(ask) || ask <= 0 || bid <= 0 || ask <= bid) return '—';
      var spr = ask - bid,
        mid = (ask + bid) / 2,
        sprBps = (spr / mid) * 10000;
      return '$' + spr.toFixed(2) + ' (' + sprBps.toFixed(0) + ' bps)';
    }

    function renderText() {
      var commTxt = fmtBps(scenario.commission_bps);
      var slipTxt = fmtBps(scenario.slippage_bps);
      var sprTxt = spreadStats();
      return (
        '<span class="k">Costs:</span> ' +
        'Commission ' +
        commTxt +
        '. ' +
        'Slippage ' +
        slipTxt +
        ' (applied to execution price: + for Buy, − for Sell). ' +
        'Current spread ' +
        sprTxt +
        '.'
      );
    }

    // 4) Create once and update text
    var $foot = jQuery('<div id="feeFootnote"></div>');
    $foot.html(renderText());
    $q.append($foot);

    // 5) Keep spread fresh
    var _ffInt = setInterval(function () {
      var node = document.getElementById('feeFootnote');
      if (!node || !document.body.contains(node)) {
        clearInterval(_ffInt);
        return;
      }
      node.innerHTML = renderText();
    }, Math.max(1200, scenario.tick_ms || 1200));
  })();

  // ===== Session metrics strip — DISABLED (now integrated into main panel) =====
  (function sessionMetricsStrip_v1_DISABLED() {
    return; // Disabled - session metrics now shown in main panel
    var $q = jQuery('#' + q.questionId);
    if (!$q.length) return;

    if (!document.getElementById('sessMetricsCSS')) {
      var css = document.createElement('style');
      css.id = 'sessMetricsCSS';
      css.textContent = `
#sessMetrics{
  display:flex;
  gap:16px;
  align-items:center;
  max-width:820px;
  margin:8px auto 0 auto;
  padding:8px 6px;
  border:1px solid #e5e7eb;
  border-radius:10px;
  background:#fafafa
}
#sessMetrics .m{
  display:flex;
  gap:6px;
  align-items:baseline;
  font-size:.85rem;
  color:#374151
}
#sessMetrics .k{
  color:#6b7280;
  font-size:.78rem
}
#sessMetrics .v{
  font-weight:600
}
@media (max-width:720px){
  #sessMetrics{flex-direction:column;align-items:flex-start}
}
`;
      document.head.appendChild(css);
    }

    var $strip = jQuery('<div id="sessMetrics"></div>');
    $strip.append(
      '<div class="m"><span class="k">Realized P/L (session):</span> <span id="sessRealized" class="v">—</span></div>'
    );
    $strip.append('<div class="m"><span class="k">Fees (session):</span> <span id="sessFees" class="v">—</span></div>');

    var $anchor = jQuery('#feeFootnote');
    if ($anchor.length) $anchor.after($strip);
    else $q.append($strip);

    function fmtSigned(n) {
      return (n >= 0 ? '+' : '') + (isFinite(n) ? Number(n).toFixed(2) : '0.00');
    }

    function refresh() {
      jQuery('#sessRealized').text(fmtSigned(rollingRealized || 0));
      jQuery('#sessFees').text(isFinite(rollingFees) ? Number(rollingFees).toFixed(2) : '0.00');
    }

    refresh();
    window._sessMetricsRefresh = refresh;
  })();

  // ===== prices & chart (robust sizing; crisp on HiDPI) =====
  var prices = [];
  try {
    prices = JSON.parse(scenario.prices_json || '[]');
  } catch (e) {
    prices = [];
  }
  
  // Generate realistic price data if we don't have enough or if it looks unrealistic
  function generateRealisticPrices(basePrice, count = 20) {
    var generated = [basePrice];
    var current = basePrice;
    var volatility = 0.02; // 2% volatility
    
    for (var i = 1; i < count; i++) {
      // Random walk with slight mean reversion
      var change = (Math.random() - 0.5) * volatility * current;
      var meanReversion = (basePrice - current) * 0.1; // Slight pull back to base
      current += change + meanReversion;
      
      // Ensure price stays positive and reasonable
      current = Math.max(current, basePrice * 0.95);
      current = Math.min(current, basePrice * 1.05);
      
      generated.push(Number(current.toFixed(2)));
    }
    
    return generated;
  }
  
  if (!prices.length || prices.length < 5) {
    var basePrice = scenario.last || 62.1;
    prices = generateRealisticPrices(basePrice, 20);
  }
  
  // Validate that prices look reasonable (not too volatile)
  if (prices.length > 1) {
    var minPrice = Math.min.apply(null, prices);
    var maxPrice = Math.max.apply(null, prices);
    var basePrice = prices[0];
    var volatility = (maxPrice - minPrice) / basePrice;
    
    // If volatility is too high (>10%), regenerate with more conservative parameters
    if (volatility > 0.1) {
      var basePrice = scenario.last || 62.1;
      prices = generateRealisticPrices(basePrice, prices.length);
    }
  }

  (function initChart() {
    var canvas = document.getElementById('px');
    if (!canvas) {
      console.warn('[Chart] canvas #px not found');
      return;
    }
    var wrap = canvas.parentElement || document.querySelector('.plotwrap');
    var cssW = wrap && wrap.clientWidth ? wrap.clientWidth - 16 : 740;
    var cssH = 180;
    var dpr = window.devicePixelRatio || 1;

    canvas.style.width = Math.max(320, cssW) + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(Math.max(320, cssW) * dpr);
    canvas.height = Math.round(cssH * dpr);

    var ctx = canvas.getContext('2d');
    if (!ctx) {
      console.warn('[Chart] 2D context not available');
      return;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale for HiDPI

    var pad = 8;

    function drawCompleteChart() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (prices.length < 2) return;

      var minP = Math.min.apply(null, prices);
      var maxP = Math.max.apply(null, prices);
      var range = maxP - minP || 0.000001;

      // Add some padding to the range for better visualization
      var padding = range * 0.1;
      minP -= padding;
      maxP += padding;
      range = maxP - minP;

      // Draw grid lines and Y-axis labels
      ctx.strokeStyle = '#f3f4f6';
      ctx.lineWidth = 1;
      ctx.fillStyle = '#6b7280';
      ctx.font = '10px Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      
      var gridLines = 5;
      for (var i = 0; i <= gridLines; i++) {
        var y = pad + (i * (cssH - 2 * pad)) / gridLines;
        
        // Draw grid line
      ctx.beginPath();
        ctx.moveTo(pad, y);
        ctx.lineTo(Math.max(320, cssW) - pad, y);
      ctx.stroke();

        // Draw Y-axis price label
        var price = maxP - (i * (maxP - minP) / gridLines);
        ctx.fillText(price.toFixed(2), pad - 8, y);
      }

      // Draw price line
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#111827';
      ctx.beginPath();
      for (var k = 0; k < prices.length; k++) {
        var x = pad + (k * (Math.max(320, cssW) - 2 * pad)) / (prices.length - 1);
        var y = pad + (cssH - 2 * pad) * (1 - (prices[k] - minP) / range);
        if (k === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Draw price points
      ctx.fillStyle = '#111827';
      for (var k = 0; k < prices.length; k++) {
        var x = pad + (k * (Math.max(320, cssW) - 2 * pad)) / (prices.length - 1);
        var y = pad + (cssH - 2 * pad) * (1 - (prices[k] - minP) / range);
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, 2 * Math.PI);
        ctx.fill();
      }

      // Add price labels at key points (start, middle, end, and significant highs/lows)
      ctx.fillStyle = '#6b7280';
      ctx.font = '11px Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      
      // Find significant points for labeling
      var labelPoints = [];
      
      // Always label start and end (but offset them slightly to avoid edge cutoff)
      if (prices.length > 1) {
        var startOffset = Math.min(2, Math.floor(prices.length / 10)); // Offset by 2 points or 10% of data
        var endOffset = Math.min(2, Math.floor(prices.length / 10));
        
        labelPoints.push({ 
          index: startOffset, 
          price: prices[startOffset], 
          label: 'Start',
          isEdge: true 
        });
        labelPoints.push({ 
          index: prices.length - 1 - endOffset, 
          price: prices[prices.length - 1 - endOffset], 
          label: 'Now',
          isEdge: true 
        });
      }
      
      // Find significant highs and lows (if we have enough data points)
      if (prices.length > 10) {
        var step = Math.max(1, Math.floor(prices.length / 8)); // Show ~8 labels max
        
        for (var i = step; i < prices.length - 1; i += step) {
          var isSignificant = false;
          var currentPrice = prices[i];
          
          // Check if this is a local high or low
          var prevPrice = prices[i - 1];
          var nextPrice = prices[i + 1];
          
          if ((currentPrice > prevPrice && currentPrice > nextPrice) || 
              (currentPrice < prevPrice && currentPrice < nextPrice)) {
            isSignificant = true;
          }
          
          // Also label some intermediate points for context
          if (i % (step * 2) === 0) {
            isSignificant = true;
          }
          
          if (isSignificant) {
            labelPoints.push({ 
              index: i, 
              price: currentPrice, 
              label: currentPrice.toFixed(2) 
            });
          }
        }
      }
      
      // Draw labels
      for (var i = 0; i < labelPoints.length; i++) {
        var point = labelPoints[i];
        var x = pad + (point.index * (Math.max(320, cssW) - 2 * pad)) / (prices.length - 1);
        var y = pad + (cssH - 2 * pad) * (1 - (point.price - minP) / range);
        
        // Draw label background
        var textWidth = ctx.measureText(point.label).width;
        var labelPadding = 4;
        var labelHeight = 16;
        
        // Calculate label position with boundary checks
        var labelX = x;
        var labelY = y - labelHeight - 2;
        
        // Ensure labels stay within chart boundaries
        var minX = pad + labelPadding;
        var maxX = Math.max(320, cssW) - pad - labelPadding;
        var minY = pad + labelPadding;
        var maxY = cssH - pad - labelPadding;
        
        // Adjust X position if label would be cut off
        if (x - textWidth/2 - labelPadding < minX) {
          labelX = minX + textWidth/2 + labelPadding;
        } else if (x + textWidth/2 + labelPadding > maxX) {
          labelX = maxX - textWidth/2 - labelPadding;
        }
        
        // Adjust Y position if label would be cut off
        if (labelY < minY) {
          labelY = y + 20; // Position below the point instead
        } else if (labelY + labelHeight > maxY) {
          labelY = y - 20; // Position above the point instead
        }
        
        // Draw label background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(
          labelX - textWidth/2 - labelPadding, 
          labelY, 
          textWidth + labelPadding * 2, 
          labelHeight
        );
        
        // Draw label border
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        ctx.strokeRect(
          labelX - textWidth/2 - labelPadding, 
          labelY, 
          textWidth + labelPadding * 2, 
          labelHeight
        );
        
        // Draw label text
        ctx.fillStyle = '#374151';
        ctx.fillText(point.label, labelX, labelY + 12);
      }

      // Update current price display
      var lastShown = prices[prices.length - 1];
      window._lastShown = lastShown;
      jQuery('#last').text(numPretty(lastShown));
      jQuery('#lastPillTxt').text(numPretty(lastShown));

      // Update unrealized P/L
      var unrl = posAvg0 != null && posQty0 > 0 ? (lastShown - posAvg0) * posQty0 : null;
      jQuery('#unrl, #unrl_bottom').text(unrl == null ? '—' : signedFmt(unrl, 2));

      // Update spread label if present
      if (document.getElementById('fee_spread')) {
        var bidN = toNum(jQuery('#bid').text());
        var askN = toNum(jQuery('#ask').text());
        if (isNum(bidN) && isNum(askN) && askN > bidN) {
          var spr = askN - bidN;
          var mid = (askN + bidN) / 2;
          var sprBps = (spr / mid) * 10000;
          jQuery('#fee_spread').text('$' + spr.toFixed(2) + ' (' + sprBps.toFixed(0) + ' bps)');
        }
      }
    }

    // Draw the complete chart immediately
    drawCompleteChart();

    // expose for debugging
    window._chart = { ctx: ctx, prices: prices, draw: drawCompleteChart };
  })();

  // ===== timer (hot) — disabled by default in Preview =====
  var t0 = Date.now();
  var FORCE_TIMERS =
    /[?&](forceTimers|forceTimer|force_timers)=1/.test(location.search) ||
    ED('debug_force_timers') === '1';
  var DEBUG_NO_TIMERS =
    /[?&](notimer|debug_notimer)=1/.test(location.search) || ED('debug_disable_timers') === '1';
  var inPreview = IS_PREVIEW || ED('is_preview') === '1';

  var timersEnabled = !!(
    scenario.hot_condition &&
    scenario.timer_sec > 0 &&
    !DEBUG_NO_TIMERS &&
    (!inPreview || FORCE_TIMERS)
  );
  
  // Debug timer settings
  console.log('TIMER DEBUG:', {
    hot_condition: scenario.hot_condition,
    timer_sec: scenario.timer_sec,
    DEBUG_NO_TIMERS: DEBUG_NO_TIMERS,
    inPreview: inPreview,
    FORCE_TIMERS: FORCE_TIMERS,
    timersEnabled: timersEnabled
  });
  console.log('TIMER VALUES:', 'hot_condition =', scenario.hot_condition, 'timer_sec =', scenario.timer_sec, 'timersEnabled =', timersEnabled);

  if (timersEnabled) {
    var t = scenario.timer_sec;
    jQuery('#timer').text(t);
    var intv = setInterval(function () {
      t--;
      jQuery('#timer').text(t);
      if (t <= 0) {
        clearInterval(intv);
        autoSubmit('timeout');
      }
    }, 1000);
  } else {
    jQuery('#timer').text('—');
  }

  // ===== order flow =====
  var pending = false,
    hinted = false,
    exec = null;

  var DEFAULT_ORDER = scenario.default_order || 'Market';
  var DEFAULT_QTY = scenario.default_qty || 200;

  // >>> pre/post instrumentation
  var preExec = null,
    preFvUsed = null,
    preEntryPxUsed = null,
    editCount = 0,
    rt_to_place_ms = null;

  // Fee/slippage + session totals scaffolding
  var SLIP_BPS = isNum(scenario.slippage_bps) ? scenario.slippage_bps : 0;
  var COMM_BPS = isNum(scenario.commission_bps) ? scenario.commission_bps : 0;
  var feesTrade = 0; // set at commit
  var realizedTrade = 0; // set if we close size on SELL or flatten

  // Sides scaffold
  var allowedSides = String(scenario.allowed_sides || '').toLowerCase();
  var buyAllowed = !allowedSides || /buy/.test(allowedSides);
  var sellAllowed = !allowedSides || /sell/.test(allowedSides);
  if (!buyAllowed && !sellAllowed) {
    console.warn('[Order] Neither side allowed; forcing Buy disabled state.');
  }

  var allowShortingFlag = String(scenario.allow_shorting || '0') === '1';
  try {
    Qualtrics.SurveyEngine.setEmbeddedData('buy_allowed', buyAllowed ? '1' : '0');
  } catch (e) {}

  // ===== One clean row: Side | Quantity | Order Type | Limit/Stop Price =====
  (function sideSelectorRow() {
    jQuery('#orderRow,#sideCSS3,#sideWrap').remove();

    // Allowed options
    var opts = [];
    if (buyAllowed) opts.push('<option value="Buy">Buy</option>');
    if (sellAllowed) opts.push('<option value="Sell">Sell</option>');
    if (opts.length === 0) return;

    // Unified row styling
    if (!document.getElementById('sideCSS3')) {
      var css = document.createElement('style');
      css.id = 'sideCSS3';
      css.textContent = `
#orderRow{display:flex;flex-wrap:wrap;gap:12px;margin-bottom:10px;align-items:flex-end}
#orderRow .field{flex:1 1 140px;min-width:120px;display:flex;flex-direction:column}
#orderRow label{font-size:.8rem;color:#6b7280;margin-bottom:2px}
#side{height:38px;padding:4px 6px;border:1px solid #d1d5db;border-radius:6px;font-size:.9rem}
@media (max-width: 720px){ #orderRow{flex-direction:column} }
`;
      document.head.appendChild(css);
    }

    // Grab existing blocks
    var $ordTypeBlock = jQuery('#ordType').length ? jQuery('#ordType').closest('div') : jQuery();
    var $pxBlock = jQuery('#ordPx').length ? jQuery('#ordPx').closest('div') : jQuery();
    var $qtyBlock = jQuery('#qty').length ? jQuery('#qty').closest('div') : jQuery();
    var $panel = jQuery('#place').closest('.QuestionBody, .card, .panel, .q-contents, form, body');
    var $anchor = $ordTypeBlock.length ? $ordTypeBlock : $panel;
    if (!$anchor.length) return;

    // Insert unified row
    var $row = jQuery('<div id="orderRow"></div>');
    $anchor.before($row);

    // Side
    $row.append(
      '<div id="sideWrap" class="field">' +
        ' <label for="side">Side</label>' +
        ' <select id="side">' +
        opts.join('') +
        '</select>' +
        '</div>'
    );

    // Quantity
    if ($qtyBlock.length) $qtyBlock.addClass('field').appendTo($row);
    // Order Type
    if ($ordTypeBlock.length) $ordTypeBlock.addClass('field').appendTo($row);
    // Limit/Stop Price
    if ($pxBlock.length) $pxBlock.addClass('field').appendTo($row);

    // Default side selection
    var defSide =
      scenario.default_side && /sell/i.test(scenario.default_side) ? 'Sell' : 'Buy';
    if (!sellAllowed && defSide === 'Sell') defSide = 'Buy';
    if (!buyAllowed && defSide === 'Buy') defSide = 'Sell';
    jQuery('#side').val(defSide);

    // Disable illegal options defensively
    if (!buyAllowed) jQuery('#side option[value="Buy"]').prop('disabled', true);
    if (!sellAllowed) jQuery('#side option[value="Sell"]').prop('disabled', true);

    // >>> NEW: hide illegal options entirely
    if (!buyAllowed) jQuery('#side option[value="Buy"]').remove();
    if (!sellAllowed) jQuery('#side option[value="Sell"]').remove();

    // >>> NEW: guard on change against programmatic/keyboard violations
    jQuery('#side').on('change', function(){
      var v = this.value;
      if (v === 'Buy' && !buyAllowed){
        alert('Buying is disabled in this scenario.');
        jQuery(this).val(sellAllowed ? 'Sell' : '');
      }
      if (v === 'Sell' && !sellAllowed){
        alert('Selling is disabled in this scenario.');
        jQuery(this).val(buyAllowed ? 'Buy' : '');
      }
    });
  })();

  // ===== strip risk controls (we're not using SL/TP in this phase) =====
  (function stripRiskControls() {
    ['sl', 'tp'].forEach(function (id) {
      var el = document.getElementById(id);
      if (el) {
        var wrap = el.closest('label, .field, div') || el;
        wrap.style.display = 'none';
        el.checked = false;
        el.disabled = true;
      }
    });
  })();

  function lastPx() {
    // prefer the current plotted last if available
    if (isNum(window._lastShown)) return window._lastShown;
    var canvasStep = window._chart && window._chart.prices ? window._chart.prices : prices;
    var idx = Math.min((canvasStep ? canvasStep.length : prices.length) - 1, prices.length - 1);
    var v = prices[idx];
    return isNum(v) ? v : scenario.last || scenario.ask || scenario.bid || 0;
  }

  function flashBalance(newBal, delta) {
    jQuery('#balanceTxt, #balanceTxt_bottom').text(numPretty(newBal));
    var cls = delta >= 0 ? 'flash-up' : 'flash-down';
    jQuery('.bal').addClass(cls);
    setTimeout(function () {
      jQuery('.bal').removeClass(cls);
    }, 600);
  }

  function resetOrderUI() {
    // preserve side choice; reset order specifics
    var sideVal = jQuery('#side').val();
    jQuery('#ordType').val(DEFAULT_ORDER);
    jQuery('#ordPx').val('');
    jQuery('#qty').val(DEFAULT_QTY);
    jQuery('#hint').hide().empty();
    jQuery('#confirm').hide();
    jQuery('#place').text('Place Order').removeClass('btn-ghost').addClass('btn-primary');
    if (document.getElementById('side')) jQuery('#side').val(sideVal);
    try {
      togglePx();
    } catch (e) {}
  }

  function entryPriceFor(e) {
    if (!e) return lastPx();
    var SIDE = e.side || 'Buy';
    var baseRef = lastPx();

    if (e.ordType === 'Market') {
      if (SIDE === 'Sell') return isNum(scenario.bid) ? scenario.bid : baseRef;
      return isNum(scenario.ask) ? scenario.ask : baseRef;
    }
    var px = isNum(e.ordPx) ? e.ordPx : baseRef;
    return isNum(px) ? px : baseRef;
  }

  function capSellQtyForNoShort(qty) {
    if (!allowShortingFlag && qty > posQty0) return Math.max(0, posQty0);
    return qty;
  }

  function renderNudge(exec, fvInput, anchorVal, herdPct, hotFlg) {
    var fvNum = coerceNum(fvInput, jQuery('#fv').val(), scenario.fair_value, lastPx());
    var askN = coerceNum(scenario.ask, jQuery('#ask').text());
    var bidN = coerceNum(scenario.bid, jQuery('#bid').text());
    var entryPx =
      exec && exec.ordType === 'Market'
        ? exec.side === 'Sell'
          ? coerceNum(scenario.bid, jQuery('#bid').text(), lastPx())
          : coerceNum(scenario.ask, jQuery('#ask').text(), lastPx())
        : coerceNum(
            exec && exec.ordPx,
            exec && exec.side === 'Sell' ? scenario.bid : scenario.ask,
            exec && exec.side === 'Sell' ? jQuery('#bid').text() : jQuery('#ask').text(),
            lastPx()
          );

    if (!isNum(fvNum)) fvNum = lastPx();
    if (!isNum(entryPx)) entryPx = lastPx();

    var spr = isNum(askN) && isNum(bidN) ? askN - bidN : 0;
    var dist = entryPx - fvNum;

    var html =
      '' +
      '<div><b>Quick check</b>: Your <span class="nh-side"></span> <span class="nh-ord"></span> entry is ' +
      '<span class="nh-dist"></span> vs fair value <span class="nh-fv"></span>.' +
      '<br>Spread is <span class="nh-spr"></span>. Consider execution cost vs expected move.';

    if (toNum(anchorVal) != null) {
      html += '<br>Do not over-weight the target <span class="nh-anchor"></span> (possible <i>anchor</i>).';
    }
    if (herdPct >= 70) {
      html += '<br>High "others buying" signal (' + herdPct + '%) can trigger <i>herding</i> bias.';
    }
    if (hotFlg) {
      html += '<br>Timer pressure can increase <i>hot</i> decisions—take a breath.';
    }
    html += '</div>';

    jQuery('#hint').html(html).show();
    jQuery('#hint .nh-ord').text(exec && exec.ordType ? exec.ordType : 'Market');
    jQuery('#hint .nh-side').text(exec && exec.side ? exec.side : 'Buy');
    jQuery('#hint .nh-dist').text(signedFmt(dist, 2));
    jQuery('#hint .nh-fv').text(fmt(fvNum, 2));
    jQuery('#hint .nh-spr').text(fmt(spr, 2));
    if (toNum(anchorVal) != null) {
      jQuery('#hint .nh-anchor').text(fmt(toNum(anchorVal), 2));
    }
  }

  // treatment flag (control vs nudge)
  function cleanAlpha(v) {
    return (v == null ? '' : String(v)).toLowerCase().replace(/[^a-z]/g, '');
  }
  // Read treatment_group from Randomizer (for production) or Global ED (for testing)
  // Use setTimeout to ensure Randomizer has executed first
  var treatmentGroupValue = '';
  var forceNudge = /[?&]nudge=1(&|$)/.test(location.search) || ED('debug_force_nudge') === '1';
  var shouldShowNudge = false;
  
  var retryCount = 0;
  var maxRetries = 5; // Stop after 1 second (5 * 200ms) - much faster for preview mode
  
  // TEMPORARY: Force nudge for testing in preview mode
  var forceNudgeForTesting = true; // Set to false when done testing
  
  function checkTreatmentGroup() {
    treatmentGroupValue = ED('treatment_group') || ED('treatment') || ED('group') || '';
    console.log('TREATMENT: Checking treatment_group:', treatmentGroupValue, '(attempt', retryCount + 1, 'of', maxRetries + 1, ')');
    
    if (treatmentGroupValue && treatmentGroupValue.trim() !== '') {
      shouldShowNudge = cleanAlpha(treatmentGroupValue) === 'nudge' || forceNudge;
      console.log('TREATMENT: Successfully read from Randomizer:', treatmentGroupValue, 'shouldShowNudge:', shouldShowNudge);
      return; // Stop retrying
    } else if (retryCount < maxRetries) {
      retryCount++;
      // Try again after a short delay
      setTimeout(checkTreatmentGroup, 200);
    } else {
      console.log('TREATMENT: Max retries reached, treatment_group still empty. Defaulting to control group.');
      shouldShowNudge = forceNudge || forceNudgeForTesting; // Show nudge if forced OR for testing
      if (forceNudgeForTesting) {
        console.log('TREATMENT: TESTING MODE - Forcing nudge to appear');
      }
    }
  }
  
  // Start checking after a delay to let Randomizer execute
  setTimeout(checkTreatmentGroup, 500);

  try {
    Qualtrics.SurveyEngine.setEmbeddedData('treatment_guard',
      shouldShowNudge ? 'nudge' : 'control');
    console.log('TREATMENT →', { 
      treatmentGroupValue: treatmentGroupValue, 
      rawFromED: ED('treatment_group'),
      forceNudge: forceNudge, 
      shouldShowNudge: shouldShowNudge,
      cleanAlphaResult: cleanAlpha(treatmentGroupValue)
    });
  } catch (e) {}

  // Debug: Log all available ED fields to see what's actually set
  try {
    console.log('DEBUG: Available ED fields:');
    var allFields = ['treatment_group', 'treatment', 'group', 'ai_nudge_enabled', 'ai_nudge_endpoint', 'commission_bps', 'slippage_bps', 'allowed_sides'];
    allFields.forEach(function(field) {
      var value = ED(field);
      console.log('  ' + field + ':', value);
    });
    
    // Debug: Try different ways to read treatment_group
    console.log('DEBUG: treatment_group reading methods:');
    console.log('  ED("treatment_group"):', ED('treatment_group'));
    console.log('  Qualtrics.SurveyEngine.getEmbeddedData("treatment_group"):', Qualtrics.SurveyEngine.getEmbeddedData('treatment_group'));
    console.log('  window._ed.treatment_group:', window._ed && window._ed.treatment_group);
    
    // Debug: Check if it's a timing issue
    setTimeout(function() {
      console.log('DEBUG: treatment_group after 1 second:', ED('treatment_group'));
    }, 1000);
  } catch(e) {}

  // Set default ED values for AI nudge tracking
  try {
    if (!ED('ai_nudge_dismissed')) Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_dismissed','0');
    if (!ED('adjust_after_ai')) Qualtrics.SurveyEngine.setEmbeddedData('adjust_after_ai','0');
  } catch(_){}

  // Place
  jQuery('#place').on('click', function (e) {
    e.preventDefault();

    if (pending) {
      // Adjust
      editCount++;
      // Mark edit after AI if AI has already been shown
      try {
        var shown = toNum(ED('ai_nudge_shown_ms'));
        if (isNum(shown) && shown > 0) {
          Qualtrics.SurveyEngine.setEmbeddedData('adjust_after_ai','1');
        }
      } catch(_){}
      pending = false;
      hinted = false;
      exec = null;
      resetOrderUI();
      return;
    }

    try {
      var sideSel = document.getElementById('side');
      var SIDE = sideSel ? sideSel.value : buyAllowed ? 'Buy' : 'Sell';
      if (SIDE === 'Buy' && !buyAllowed) {
        alert('Buying is disabled in this scenario.');
        return;
      }
      if (SIDE === 'Sell' && !sellAllowed) {
        alert('Selling is disabled in this scenario.');
        return;
      }

      var ordType = jQuery('#ordType').val();
      var ordPxRaw = jQuery('#ordPx').val();
      var ordPx = ordPxRaw === '' || ordPxRaw == null ? NaN : parseFloat(ordPxRaw);
      var qty = parseInt(jQuery('#qty').val(), 10) || 0;
      var useSL = 0,
        useTP = 0; // risk controls disabled in this phase

      if (qty < 0) {
        alert('Quantity cannot be negative.');
        return;
      }
      
      // Allow 0 quantity (user can adjust without placing order)
      if (qty === 0) {
        alert('Please enter a quantity greater than 0 to place an order, or adjust your order above.');
        return;
      }
      if (ordType !== 'Market' && isNaN(ordPx)) {
        alert('Enter a valid price for Limit/Stop.');
        return;
      }
      
      // Get current balance and position
      var currentBalance = parseFloat(jQuery('#balanceTxt_bottom').text().replace(/[,$]/g, '')) || 0;
      var currentPosition = parseInt(jQuery('#posQty_bottom').text()) || 0;
      
      // Check balance for buy orders
      if (SIDE === 'Buy') {
        var price = ordType === 'Market' ? parseFloat(scenario.last) : ordPx;
        var totalCost = qty * price;
        if (totalCost > currentBalance) {
          var maxShares = Math.floor(currentBalance / price);
          alert('Insufficient balance. You can buy a maximum of ' + maxShares + ' shares with your current balance of $' + currentBalance.toLocaleString() + '.');
          return;
        }
      }
      
      // Check position for sell orders
      if (SIDE === 'Sell') {
        if (qty > currentPosition) {
          alert('Insufficient position. You can only sell ' + currentPosition + ' shares (you currently hold ' + currentPosition + ' shares).');
          return;
        }
      }

      if (SIDE === 'Sell' && !allowShortingFlag) {
        // cap to current long if shorting not allowed
        var capped = capSellQtyForNoShort(qty);
        if (capped === 0) {
          alert('No long position to sell. Shorting is disabled.');
          return;
        }
        if (capped !== qty) {
          qty = capped;
          jQuery('#qty').val(String(qty));
        }
      }

      // hypothetical fill (pre-slippage) – side-aware reference
      var baseRef = lastPx(),
        filled = 0,
        fillPx = baseRef;

      if (ordType === 'Market') {
        fillPx = SIDE === 'Sell' ? (isNum(scenario.bid) ? scenario.bid : lastPx()) : isNum(scenario.ask) ? scenario.ask : lastPx();
        filled = qty;
      } else if (ordType === 'Limit') {
        if (!isNaN(ordPx)) {
          if (SIDE === 'Sell') {
            if (isNum(scenario.bid) && ordPx <= scenario.bid) {
              fillPx = ordPx;
              filled = qty;
            } else {
              fillPx = ordPx;
              filled = Math.floor(qty * Math.max(0, isNum(scenario.bid) ? scenario.bid / ordPx : 0));
            }
          } else {
            if (isNum(scenario.ask) && ordPx >= scenario.ask) {
              fillPx = ordPx;
              filled = qty;
            } else {
              fillPx = ordPx;
              filled = Math.floor(qty * Math.max(0, isNum(scenario.ask) ? ordPx / scenario.ask : 0));
            }
          }
        } else {
          fillPx = SIDE === 'Sell' ? scenario.bid || lastPx() : scenario.ask || lastPx();
          filled = 0;
        }
      } else if (ordType === 'Stop') {
        if (!isNaN(ordPx)) {
          if (SIDE === 'Sell') {
            if (lastPx() <= ordPx) {
              fillPx = lastPx();
              filled = qty;
            }
          } else {
            if (lastPx() >= ordPx) {
              fillPx = lastPx();
              filled = qty;
            }
          }
        }
      }

      exec = {
        side: SIDE,
        ordType: ordType,
        ordPx: isNaN(ordPx) ? null : ordPx,
        qty: qty,
        filled: filled,
        fillPx: fillPx,
        useSL: useSL,
        useTP: useTP,
        cash_delta: 0,
        ts: Date.now()
      };

      // first Place snapshot
      if (preExec == null) {
        preExec = {
          side: SIDE,
          ordType: exec.ordType,
          ordPx: exec.ordPx,
          qty: exec.qty,
          filled: exec.filled,
          fillPx: exec.fillPx,
          ts: exec.ts
        };
        preFvUsed = coerceNum(jQuery('#fv').val(), scenario.fair_value, lastPx());
        if (!isNum(preFvUsed)) preFvUsed = lastPx();
        preEntryPxUsed = entryPriceFor(exec);
        rt_to_place_ms = Date.now() - t0;
      }

      // === AI Nudge: fire on first Place (non-blocking), only for nudge group ===
      try {
        var AI_ENABLED = (ED('ai_nudge_enabled') || '1') !== '0';
        console.log('AI_ENABLED DEBUG: raw ED value:', ED('ai_nudge_enabled'), 'parsed:', AI_ENABLED);
        Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_req_ms', String(Date.now()));
        Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_used', '0'); // flips to 1 if we render
        Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_shown_ms', '');

        // create a tiny pending row under #hint while waiting
        (function ensurePending(){
          var $hint = jQuery('#hint');
          console.log('AI SPINNER: Looking for #hint element:', $hint.length);
          if (!$hint.length) {
            console.log('AI SPINNER: #hint element not found!');
            return;
          }
          var el = document.getElementById('aiNudgePending');
          if (!el) {
            console.log('AI SPINNER: Creating spinner element');
            el = document.createElement('div');
            el.id = 'aiNudgePending';
            el.style.cssText = 'margin-top:12px;padding:12px;border:2px solid #3b82f6;border-radius:8px;background:linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);font-size:.9rem;color:#1e40af;font-weight:600;text-align:center;box-shadow:0 4px 6px -1px rgba(0,0,0,0.1);';
            el.innerHTML = '🤖 AI is analyzing your trade… <span style="animation: pulse 1.5s infinite;font-size:1.2em;">⏳</span>';
            
            // Add CSS for pulse animation if not already present
            if (!document.getElementById('pulse-css')) {
              var style = document.createElement('style');
              style.id = 'pulse-css';
              style.textContent = '@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }';
              document.head.appendChild(style);
            }
            $hint.append(el).show();
            console.log('AI SPINNER: Spinner created and shown');
          } else {
            console.log('AI SPINNER: Spinner already exists');
          }
        })();

        // Check treatment group again at the time of nudge request
        var currentTreatmentGroup = ED('treatment_group') || ED('treatment') || ED('group') || '';
        var currentShouldShowNudge = (cleanAlpha(currentTreatmentGroup) === 'generic_nudge' || cleanAlpha(currentTreatmentGroup) === 'nudge') || forceNudge || forceNudgeForTesting;
        var currentAIEndpoint = ED('ai_nudge_endpoint') || 'https://YOUR_API_HOST/nudge';
        console.log('NUDGE CHECK: treatment_group:', currentTreatmentGroup, 'shouldShowNudge:', currentShouldShowNudge, 'forceNudgeForTesting:', forceNudgeForTesting);
        console.log('AI CHECK: AI_ENABLED:', AI_ENABLED, 'AI_NUDGE_ENDPOINT:', AI_NUDGE_ENDPOINT, 'currentAIEndpoint:', currentAIEndpoint);
        console.log('AI CHECK: AI_ENABLED type:', typeof AI_ENABLED, 'AI_NUDGE_ENDPOINT type:', typeof AI_NUDGE_ENDPOINT);
        console.log('AI CHECK: AI_ENABLED truthy:', !!AI_ENABLED, 'AI_NUDGE_ENDPOINT truthy:', !!AI_NUDGE_ENDPOINT, 'currentAIEndpoint truthy:', !!currentAIEndpoint);
        
        console.log('CONDITION CHECK: currentShouldShowNudge:', currentShouldShowNudge, 'AI_ENABLED:', AI_ENABLED, 'currentAIEndpoint:', currentAIEndpoint, 'endpoint check:', currentAIEndpoint !== 'https://YOUR_API_HOST/nudge');
        console.log('CONDITION RESULT:', currentShouldShowNudge && AI_ENABLED && currentAIEndpoint && currentAIEndpoint !== 'https://YOUR_API_HOST/nudge');
        
        // 3-Arm RCT Logic
        if (currentShouldShowNudge) {
          console.log('AI NUDGE: ENTERING IF BLOCK - All conditions met!');
          
          var currentTreatmentGroup = ED('treatment_group') || '';
          var payload;
          var aiEndpoint;
          
          if (currentTreatmentGroup === 'generic_nudge') {
            console.log('AI NUDGE: Using generic nudge payload');
            payload = buildGenericNudgePayload(exec);
            aiEndpoint = currentAIEndpoint.replace('/nudge', '/generic-nudge');
          } else if (currentTreatmentGroup === 'nudge') {
            console.log('AI NUDGE: Using enhanced nudge payload');
            payload = buildNudgePayload(exec);
            aiEndpoint = currentAIEndpoint.replace('/nudge', '/enhanced-nudge');
          } else if (currentTreatmentGroup === '') {
            // Fallback for testing when treatment_group is not set
            console.log('AI NUDGE: Treatment group empty, using enhanced nudge as fallback for testing');
            payload = buildNudgePayload(exec);
            aiEndpoint = currentAIEndpoint.replace('/nudge', '/enhanced-nudge');
          } else {
            console.log('AI NUDGE: Unknown treatment group:', currentTreatmentGroup);
            return;
          }
          
          console.log('AI NUDGE: Sending request to', aiEndpoint);
          console.log('AI NUDGE: Payload:', payload);
          console.log('AI NUDGE: Payload size:', JSON.stringify(payload).length, 'bytes');
          console.log('AI NUDGE: Timeout value:', AI_NUDGE_TIMEOUT_MS);

          postJSON(aiEndpoint, payload, AI_NUDGE_TIMEOUT_MS, function(err, json){
            console.log('AI NUDGE: Response received', { err: err, json: json });
            console.log('AI NUDGE: Error details:', err ? { name: err.name, message: err.message, code: err.code } : 'none');
            // remove pending row either way
            var p = document.getElementById('aiNudgePending'); if (p && p.parentNode) p.parentNode.removeChild(p);
            if (err || !json) {
              // AI failed - show Quick check as fallback
        renderNudge(
          exec,
          jQuery('#fv').val(),
          scenario.anchor_target,
          scenario.sentiment_pct,
          scenario.hot_condition
        );
              // Show confirm button for fallback
        jQuery('#confirm').show();
              return; // fail soft
            }

            // Expect shape: { suggestion_html?, suggestion_text?, model?, meta? }
            var html = '';
            if (json.suggestion_html && typeof json.suggestion_html === 'string') {
              html = sanitizeAiHtml(json.suggestion_html); // allow-list sanitize
            } else if (json.suggestion_text && typeof json.suggestion_text === 'string') {
              html = '<div>'+ escapeHtml(json.suggestion_text) +'</div>';
            }

            // hard length cap (defensive)
            if (html && html.length > 3000) {
              html = escapeHtml(html.slice(0, 3000)) + '…';
              try { Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_truncated','1'); } catch(_){}
            } else {
              try { Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_truncated','0'); } catch(_){}
            }

            if (html) {
              appendAiNudge(html);
              try {
                Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_used','1');
                Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_shown_ms', String(Date.now()));
                Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_resp_len', String(html.length));
              } catch(_){}
              
              // Show confirm button now that AI response is displayed
              jQuery('#confirm').show();

              // Add dismiss button
              try {
                var hint = document.getElementById('hint');
                if (hint) {
                  var btn = document.createElement('a');
                  btn.href = '#';
                  btn.textContent = 'Dismiss';
                  btn.style.cssText = 'margin-left:8px;font-size:.75rem;color:#6b7280;text-decoration:underline;';
                  btn.onclick = function(ev){
                    ev.preventDefault();
                    var chunks = hint.querySelectorAll('.ai-nudge-chunk');
                    chunks.forEach(function(n){ n.style.display = 'none'; });
                    try { Qualtrics.SurveyEngine.setEmbeddedData('ai_nudge_dismissed','1'); } catch(_){}
                  };
                  var lastChunk = hint.querySelector('.ai-nudge-chunk');
                  if (lastChunk) lastChunk.appendChild(btn);
                }
              } catch(_){}
            }
          });
        } else {
          // not firing: remove pending indicator
          console.log('AI NUDGE: Not firing - shouldShowNudge:', currentShouldShowNudge, 'AI_ENABLED:', AI_ENABLED, 'currentAIEndpoint:', currentAIEndpoint);
          var p2 = document.getElementById('aiNudgePending'); if (p2 && p2.parentNode) p2.parentNode.removeChild(p2);
        }
      } catch(_e) {}

      // Check treatment group again at the time of nudge display
      var currentTreatmentGroup = ED('treatment_group') || ED('treatment') || ED('group') || '';
      var currentShouldShowNudge = cleanAlpha(currentTreatmentGroup) === 'nudge' || forceNudge || forceNudgeForTesting;
      
      if (currentShouldShowNudge) {
        hinted = true;
        // Don't show Quick check here - AI nudge will handle it
        // renderNudge will only be called as fallback if AI fails
        // Don't show confirm button yet - wait for AI response
        jQuery('#confirm').hide();
        jQuery('#place').text('Adjust Order').removeClass('btn-primary').addClass('btn-ghost');
        // Don't show any hint yet - wait for AI response
      } else {
        // For control group, show confirm button immediately
        jQuery('#confirm').show();
      }

      pending = true;
    } catch (err) {
      try {
        console.error('Error in Place:', err);
      } catch (e) {}
      jQuery('#confirm').show();
      pending = true;
    }
  });

  // Confirm
  jQuery('#confirm').on('click', function (e) {
    e.preventDefault();
    if (!pending) {
      return;
    }

    try {
      var SIDE = (exec && exec.side) || 'Buy';
      var filled = (exec && exec.filled) || 0;
      var baseFillPx = (exec && exec.fillPx) || lastPx();

      // slippage applied to price:
      // Buy: price * (1 + SLIP), Sell: price * (1 - SLIP)
      var slipMult = SIDE === 'Sell' ? 1 - SLIP_BPS / 10000 : 1 + SLIP_BPS / 10000;
      var effFillPx = baseFillPx * slipMult;

      // commissions on effective notional
      var notionalEff = filled * effFillPx;
      feesTrade = (COMM_BPS / 10000) * Math.abs(notionalEff);

      // cash impact
      var delta = SIDE === 'Sell' ? +notionalEff - (feesTrade || 0) : -notionalEff - (feesTrade || 0);
      exec.cash_delta = delta;

      var newBal = balance0 + delta;
      flashBalance(newBal, delta);
      balance0 = newBal;

      // position updates + realized P/L if SELL reduces existing long
      realizedTrade = 0;

      if (SIDE === 'Buy') {
        if (filled > 0) {
          var priorNotional = posAvg0 != null ? posAvg0 * posQty0 : 0;
          var newNotional = priorNotional + effFillPx * filled;
          posQty0 = posQty0 + filled;
          posAvg0 = posQty0 > 0 ? newNotional / posQty0 : null;
        }
      } else {
        // SELL
        if (filled > 0) {
          var reduce = Math.min(filled, Math.max(0, posQty0 | 0));
          var extra = filled - reduce; // possible short open
          if (reduce > 0) {
            if (isNum(posAvg0)) {
              realizedTrade += (effFillPx - posAvg0) * reduce;
            }
            var remainingQty = posQty0 - reduce;
            if (remainingQty <= 0) {
              posQty0 = 0;
              posAvg0 = null;
            } else {
              var remainingNotional = posAvg0 * remainingQty;
              posQty0 = remainingQty;
              posAvg0 = remainingNotional / remainingQty;
            }
          }
          if (extra > 0) {
            if (!allowShortingFlag) {
              var extraNotional = extra * effFillPx;
              var extraFees = (COMM_BPS / 10000) * Math.abs(extraNotional);
              var refund = -(+extraNotional - extraFees);
              balance0 += refund;
              flashBalance(balance0, refund);
              exec.filled = reduce;
            } else {
              posQty0 = posQty0 - extra; // becomes negative
              posAvg0 = effFillPx;
            }
          }
        }
      }

      // update UI
      jQuery('#posQty, #posQty_bottom').text(posQty0);
      jQuery('#posPx').text(posAvg0 != null && isFinite(posAvg0) ? posAvg0.toFixed(2) : '—');

      // rolling session updates
      rollingFees = (rollingFees || 0) + (feesTrade || 0);
      rollingRealized = (rollingRealized || 0) + (realizedTrade || 0);

      try {
        Qualtrics.SurveyEngine.setEmbeddedData('exec_fillPx_eff', effFillPx.toFixed(4));
        Qualtrics.SurveyEngine.setEmbeddedData('fees_trade', (feesTrade || 0).toFixed(2));
        Qualtrics.SurveyEngine.setEmbeddedData('side', SIDE);
      } catch (e) {}

      // Refresh metrics strip
      try {
        if (typeof window._sessMetricsRefresh === 'function') window._sessMetricsRefresh();
      } catch (_e) {}

      // Optional tiny toast for quick QA:
      try {
        var el = document.getElementById('commitToast');
        if (!el) {
          el = document.createElement('div');
          el.id = 'commitToast';
          el.style.cssText =
            'position:fixed;right:12px;bottom:12px;padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;box-shadow:0 4px 16px rgba(0,0,0,.08);font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;z-index:9999';
          document.body.appendChild(el);
        }
        el.innerHTML =
          '<b>' +
          (exec.side || 'Buy') +
          '</b> ' +
          (exec.filled || 0) +
          ' @ ' +
          (effFillPx ? effFillPx.toFixed(4) : '—') +
          '<br>Fees: ' +
          (feesTrade || 0).toFixed(2) +
          '<br>Realized: ' +
          (realizedTrade || 0).toFixed(2);
        el.style.opacity = '1';
        setTimeout(function () {
          el.style.opacity = '0';
        }, 1800);
      } catch (_e) {}
    } catch (err) {
      try {
        console.error('Commit error:', err);
      } catch (e) {}
    }

    try {
      jQuery('#confirm,#place').prop('disabled', true);
    } catch (e) {}
    submitAndAdvance('ok');
  });

  // ===== advance (one-shot, scoped to this page only) =====
  var ADV_QID = q.questionId; // current question container id

  function stillHere() {
    return !!document.getElementById(ADV_QID);
  }

  function reveal(nb) {
    try {
      nb.style.position = '';
      nb.style.left = '';
      nb.style.top = '';
      nb.style.visibility = 'visible';
      nb.style.opacity = '1';
      nb.style.display = 'block';
      nb.style.pointerEvents = 'auto';
      nb.disabled = false;
      nb.removeAttribute('hidden');
      nb.removeAttribute('aria-hidden');
      nb.removeAttribute('data-runtime-disabled');
      nb.removeAttribute('data-runtime-hide');
      if (nb.scrollIntoView) nb.scrollIntoView({ block: 'center', inline: 'center' });
    } catch (e) {}
  }

  // single-use lock so we never click twice on this page
  var NAV_LOCK = false;

  function advance() {
    if (NAV_LOCK) return;
    NAV_LOCK = true;

    // Enable Qualtrics next
    try {
      q.enableNextButton && q.enableNextButton();
    } catch (e) {}

    // Prefer Qualtrics API (scoped), then local #NextButton fallback
    try {
      Qualtrics.SurveyEngine &&
        Qualtrics.SurveyEngine.navClick &&
        Qualtrics.SurveyEngine.navClick('NextButton');
    } catch (e) {}

    try {
      var nb = document.getElementById('NextButton');
      if (nb) {
        reveal(nb);
        nb.click();
      }
    } catch (e) {}

    // Release lock once the question is gone from DOM
    try {
      var obs = new MutationObserver(function () {
        if (!stillHere()) {
          try {
            obs.disconnect();
          } catch (_e) {}
          NAV_LOCK = false;
        }
      });
      obs.observe(document.body, { childList: true, subtree: true });

      // hard timeout safety
      setTimeout(function () {
        NAV_LOCK = false;
        try {
          obs.disconnect();
        } catch (_e) {}
      }, 2000);
    } catch (e) {
      setTimeout(function () {
        NAV_LOCK = false;
      }, 2000);
    }
  }

  // ===== save + advance =====
  function submitAndAdvance(reason) {
    try {
      var rt = Date.now() - t0;
      var fv = toNum(jQuery('#fv').val());
      var target = toNum(jQuery('#target').val());
      if (target == null && isNum(scenario.anchor_target)) target = scenario.anchor_target;

      // compute unrealized at exit price (last tick)
      var lastAtExit = isNum(window._lastShown) ? window._lastShown : toNum(jQuery('#last').text());
      var unrlExit =
        posAvg0 != null && posQty0 > 0 && isFinite(lastAtExit) ? (lastAtExit - posAvg0) * posQty0 : 0;

      // realize or carry per close_method
      var cm = (scenario.close_method || '').toLowerCase();
      var realizedFromFlatten = 0;

      if (cm === 'close_at_last') {
        // realize P/L and flatten
        balance0 = balance0 + (isNum(unrlExit) ? unrlExit : 0);
        realizedFromFlatten = isNum(unrlExit) ? unrlExit : 0;
        posQty0 = 0;
        posAvg0 = null;
        jQuery('#balanceTxt, #balanceTxt_bottom').text(numPretty(balance0));
        jQuery('#posQty, #posQty_bottom').text(0);
        jQuery('#posPx').text('—');
        jQuery('#unrl, #unrl_bottom').text('—');
      }

      // session roll-ups (fees already rolled on commit; realized includes any SELL close + flatten)
      var realizedThisScenario = (realizedTrade || 0) + (realizedFromFlatten || 0);
      rollingRealized = (rollingRealized || 0) + (realizedFromFlatten || 0);

      // refresh metrics strip for any flatten adjustments
      try {
        if (typeof window._sessMetricsRefresh === 'function') window._sessMetricsRefresh();
      } catch (_e) {}

      var metrics = deriveBias(exec, fv, target, scenario.sentiment_pct);

      // deltas
      var postEntry = entryPriceFor(exec);
      var fvNow = isNum(fv) ? fv : toNum(scenario.fair_value);
      var preDist =
        isNum(preEntryPxUsed) && isNum(preFvUsed) ? preEntryPxUsed - preFvUsed : null;
      var postDist = isNum(postEntry) && isNum(fvNow) ? postEntry - fvNow : null;

      var changed = 0,
        changedFields = [];
      if (preExec) {
        if ((preExec.side || '') !== ((exec && exec.side) || '')) {
          changed = 1;
          changedFields.push('side');
        }
        if ((preExec.ordType || '') !== ((exec && exec.ordType) || '')) {
          changed = 1;
          changedFields.push('ordType');
        }
        if (String(preExec.ordPx || '') !== String((exec && exec.ordPx) || '')) {
          changed = 1;
          changedFields.push('ordPx');
        }
        if (String(preExec.qty || '') !== String((exec && exec.qty) || '')) {
          changed = 1;
          changedFields.push('qty');
        }
      }

      // core ED
      Qualtrics.SurveyEngine.setEmbeddedData('rt_ms', rt);
      Qualtrics.SurveyEngine.setEmbeddedData('hint_shown', hinted ? '1' : '0');
      Qualtrics.SurveyEngine.setEmbeddedData('exec_side', exec && exec.side);
      Qualtrics.SurveyEngine.setEmbeddedData('exec_ordType', exec && exec.ordType);
      Qualtrics.SurveyEngine.setEmbeddedData('exec_ordPx', exec && exec.ordPx);
      Qualtrics.SurveyEngine.setEmbeddedData('exec_qty', exec && exec.qty);
      Qualtrics.SurveyEngine.setEmbeddedData('exec_filled', exec && exec.filled);
      Qualtrics.SurveyEngine.setEmbeddedData('exec_fillPx', exec && exec.fillPx);
      Qualtrics.SurveyEngine.setEmbeddedData('cash_delta', exec && exec.cash_delta);
      Qualtrics.SurveyEngine.setEmbeddedData('new_balance', balance0);
      Qualtrics.SurveyEngine.setEmbeddedData('autosubmit_reason', reason || '');
      Qualtrics.SurveyEngine.setEmbeddedData('bias_is_biased', metrics.is_biased ? '1' : '0');
      Qualtrics.SurveyEngine.setEmbeddedData('bias_anchor_dist', metrics.anchor_dist.toFixed(4));
      Qualtrics.SurveyEngine.setEmbeddedData('bias_fv_dist', metrics.fv_dist.toFixed(4));
      Qualtrics.SurveyEngine.setEmbeddedData(
        'bias_herd_suscept',
        metrics.herd_suscept.toFixed(4)
      );
      Qualtrics.SurveyEngine.setEmbeddedData('bias_focus_active', metrics.focus_active);
      Qualtrics.SurveyEngine.setEmbeddedData('herding_threshold_pct', metrics.herd_thr_pct);
      Qualtrics.SurveyEngine.setEmbeddedData(
        'ev_hold',
        evHold(lastPx(), scenario.p_up, scenario.up_ret, scenario.down_ret).toFixed(6)
      );
      Qualtrics.SurveyEngine.setEmbeddedData('balance', balance0);

      // analytics ED
      Qualtrics.SurveyEngine.setEmbeddedData('pre_side', preExec && preExec.side);
      Qualtrics.SurveyEngine.setEmbeddedData('pre_ordType', preExec && preExec.ordType);
      Qualtrics.SurveyEngine.setEmbeddedData('pre_ordPx', preExec && preExec.ordPx);
      Qualtrics.SurveyEngine.setEmbeddedData('pre_qty', preExec && preExec.qty);
      Qualtrics.SurveyEngine.setEmbeddedData('pre_filled', preExec && preExec.filled);
      Qualtrics.SurveyEngine.setEmbeddedData('pre_fillPx', preExec && preExec.fillPx);
      Qualtrics.SurveyEngine.setEmbeddedData('pre_fv', isNum(preFvUsed) ? preFvUsed : '');
      Qualtrics.SurveyEngine.setEmbeddedData(
        'pre_entryPx',
        isNum(preEntryPxUsed) ? preEntryPxUsed : ''
      );
      Qualtrics.SurveyEngine.setEmbeddedData(
        'pre_dist_to_fv',
        isNum(preDist) ? preDist.toFixed(4) : ''
      );
      Qualtrics.SurveyEngine.setEmbeddedData(
        'post_entryPx',
        isNum(postEntry) ? postEntry : ''
      );
      Qualtrics.SurveyEngine.setEmbeddedData('post_fv', isNum(fvNow) ? fvNow : '');
      Qualtrics.SurveyEngine.setEmbeddedData(
        'post_dist_to_fv',
        isNum(postDist) ? postDist.toFixed(4) : ''
      );
      Qualtrics.SurveyEngine.setEmbeddedData('changed_after_nudge', String(changed));
      Qualtrics.SurveyEngine.setEmbeddedData('adjust_after_ai', ED('adjust_after_ai') || '0');
      Qualtrics.SurveyEngine.setEmbeddedData('changed_fields', changedFields.join(','));
      Qualtrics.SurveyEngine.setEmbeddedData('adjust_count', String(editCount));
      Qualtrics.SurveyEngine.setEmbeddedData(
        'rt_to_place_ms',
        rt_to_place_ms == null ? '' : String(rt_to_place_ms)
      );

      // end-state + carry-forward persistence
      Qualtrics.SurveyEngine.setEmbeddedData('pos_qty_after', String(posQty0));
      Qualtrics.SurveyEngine.setEmbeddedData(
        'pos_px_after',
        posAvg0 != null && isFinite(posAvg0) ? posAvg0.toFixed(4) : ''
      );
      Qualtrics.SurveyEngine.setEmbeddedData(
        'unrl_last',
        unrlExit != null && isFinite(unrlExit) ? unrlExit.toFixed(2) : '0'
      );

      if (ED('carry_forward') === '1') {
        Qualtrics.SurveyEngine.setEmbeddedData('rolling_balance', balance0);
        Qualtrics.SurveyEngine.setEmbeddedData('rolling_pos_qty', String(posQty0));
        Qualtrics.SurveyEngine.setEmbeddedData(
          'rolling_pos_px',
          posAvg0 != null && isFinite(posAvg0) ? posAvg0.toFixed(6) : ''
        );
      }

      // fees & realized P/L EDs (per trade + session rollups)
      Qualtrics.SurveyEngine.setEmbeddedData('fees_trade', (feesTrade || 0).toFixed(2));
      Qualtrics.SurveyEngine.setEmbeddedData(
        'fees_session',
        (rollingFees || 0).toFixed(2)
      );
      Qualtrics.SurveyEngine.setEmbeddedData(
        'realized_pl_trade',
        (realizedThisScenario || 0).toFixed(2)
      );
      Qualtrics.SurveyEngine.setEmbeddedData(
        'realized_pl_session',
        (rollingRealized || 0).toFixed(2)
      );

      // persist session totals for next page
      Qualtrics.SurveyEngine.setEmbeddedData(
        'rolling_fees',
        (rollingFees || 0).toFixed(6)
      );
      Qualtrics.SurveyEngine.setEmbeddedData(
        'rolling_realized_pl',
        (rollingRealized || 0).toFixed(6)
      );

      // ===== Phase 4 Rollups: per-scenario update & finalization =====
      try {
        // 1) Gather per-scenario facts
        var _rt = isFinite(rt) ? rt : 0;
        var _hint = hinted ? 1 : 0;
        var _realizedThis = isFinite(realizedThisScenario) ? realizedThisScenario : 0;
        var _feesThis = isFinite(feesTrade) ? feesTrade : 0;

        // end-of-scenario balance (after any flatten)
        var endBal = isFinite(balance0) ? balance0 : ssGetNum(ACC.BAL_LAST, 0);

        // 2) Update running sums / counts
        ssSetNum(ACC.RT_SUM, ssGetNum(ACC.RT_SUM, 0) + _rt);
        ssSetNum(ACC.N_SCEN, ssGetNum(ACC.N_SCEN, 0) + 1);
        ssSetNum(ACC.HINT_N, ssGetNum(ACC.HINT_N, 0) + _hint);
        ssSetNum(ACC.REALIZED, ssGetNum(ACC.REALIZED, 0) + _realizedThis);
        ssSetNum(ACC.FEES, ssGetNum(ACC.FEES, 0) + _feesThis);

        // 3) Drawdown (currency) using balance peak
        var prevHWM = ssGetNum(ACC.HWM, endBal);
        var newHWM = Math.max(prevHWM, endBal);
        ssSetNum(ACC.HWM, newHWM);

        var ddNow = Math.max(0, newHWM - endBal);
        var prevMaxDD = ssGetNum(ACC.MAX_DD, 0);
        var newMaxDD = Math.max(prevMaxDD, ddNow);
        ssSetNum(ACC.MAX_DD, newMaxDD);

        // 3b) Drawdown percentage (0–100)
        var hwm = ssGetNum(ACC.HWM, endBal);
        var ddPctNow = hwm > 0 ? ((Math.max(0, hwm - endBal) / hwm) * 100) : 0;
        var prevMaxDDPct = ssGetNum(ACC.MAX_DD_PCT, 0);
        var newMaxDDPct = Math.max(prevMaxDDPct, ddPctNow);
        ssSetNum(ACC.MAX_DD_PCT, newMaxDDPct);

        // 4) Persist last balance
        ssSetNum(ACC.BAL_LAST, endBal);

        // 5) Write incremental rollups to ED
        var _n = ssGetNum(ACC.N_SCEN, 0);
        var avgRT = _n > 0 ? ssGetNum(ACC.RT_SUM, 0) / _n : 0;
        var hintRate = _n > 0 ? (ssGetNum(ACC.HINT_N, 0) / _n) : 0;

        Qualtrics.SurveyEngine.setEmbeddedData('roll_rt_sum', ssGetNum(ACC.RT_SUM, 0).toFixed(0));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_n_scen', String(_n));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_hint_n', String(ssGetNum(ACC.HINT_N, 0)));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_realized', ssGetNum(ACC.REALIZED, 0).toFixed(2));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_fees', ssGetNum(ACC.FEES, 0).toFixed(2));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_balance_last', endBal.toFixed(2));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_hwm', ssGetNum(ACC.HWM, endBal).toFixed(2));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_max_drawdown', ssGetNum(ACC.MAX_DD, 0).toFixed(2));
        Qualtrics.SurveyEngine.setEmbeddedData('roll_max_drawdown_pct', ssGetNum(ACC.MAX_DD_PCT, 0).toFixed(2));
        Qualtrics.SurveyEngine.setEmbeddedData('avg_rt_ms', avgRT.toFixed(0));
        Qualtrics.SurveyEngine.setEmbeddedData('hint_rate', hintRate.toFixed(4));

        // 6) Finalization on last scenario
        var isLast =
          (TOTAL_LOOPS && !isNaN(TOTAL_LOOPS) && !isNaN(seqNum) && seqNum === TOTAL_LOOPS) ||
          (ED('is_last_scenario') === '1');

        if (isLast) {
          var unrealizedFinal = isFinite(unrlExit) ? unrlExit : 0;

          Qualtrics.SurveyEngine.setEmbeddedData('realized_pl_total', ssGetNum(ACC.REALIZED, 0).toFixed(2));
          Qualtrics.SurveyEngine.setEmbeddedData('unrealized_pl_final', unrealizedFinal.toFixed(2));
          Qualtrics.SurveyEngine.setEmbeddedData('max_drawdown', ssGetNum(ACC.MAX_DD, 0).toFixed(2));
          Qualtrics.SurveyEngine.setEmbeddedData('max_drawdown_pct', ssGetNum(ACC.MAX_DD_PCT, 0).toFixed(2));
          Qualtrics.SurveyEngine.setEmbeddedData('avg_rt_ms', avgRT.toFixed(0));
          Qualtrics.SurveyEngine.setEmbeddedData('hint_rate', hintRate.toFixed(4));

          // Optional: clear accumulators at end of run
          try {
            [ACC.RT_SUM, ACC.N_SCEN, ACC.HINT_N, ACC.REALIZED, ACC.FEES, ACC.BAL_LAST, ACC.HWM, ACC.MAX_DD, ACC.MAX_DD_PCT]
              .forEach(function (k) { sessionStorage.removeItem(k); });
          } catch (_) {}
        }
      } catch (e) {
        try { console.error('[Phase4] rollups error:', e); } catch (_) {}
      }
      // ===== /Phase 4 Rollups =====

    } catch (err) {
      try {
        console.error('submitAndAdvance error:', err);
      } catch (e) {}
    }

    advance();
  }

  function autoSubmit(reason) {
    submitAndAdvance(reason);
  }

function deriveBias(exec, fv, target, herd) {
  // Entry price used for “bias” checks
  var px =
    exec && exec.ordType === 'Market'
      ? (exec && exec.side) === 'Sell'
        ? (isNum(scenario.bid) ? scenario.bid : lastPx())
        : (isNum(scenario.ask) ? scenario.ask : lastPx())
      : (exec && exec.ordPx != null)
        ? exec.ordPx
        : (exec && exec.side) === 'Sell'
          ? (isNum(scenario.bid) ? scenario.bid : lastPx())
          : (isNum(scenario.ask) ? scenario.ask : lastPx());

  if (!isNum(px)) px = lastPx();

  var fvSrc = isNum(fv) ? fv : toNum(scenario.fair_value);
  var fvDist = isNum(fvSrc) ? (px - fvSrc) : 0;

  var halfSpread = (isNum(scenario.ask) && isNum(scenario.bid) && scenario.ask > scenario.bid)
    ? (scenario.ask - scenario.bid) / 2
    : 0.05; // fallback

  // Configurable herding threshold (ED override → default 70)
  var herdThrRaw = ED('herding_threshold_pct');
  var herdThr = isNum(toNum(herdThrRaw)) ? toNum(herdThrRaw) : 70;

  // Optional gating via bias_focus (comma list e.g. "anchor,fv,herd,hot")
  var focusRaw = (ED('bias_focus') || '').toLowerCase().replace(/\s+/g, '');
  var focusSet = focusRaw ? focusRaw.split(',') : ['anchor','fv','herd','hot'];

  function wants(k){ return focusSet.indexOf(k) !== -1; }

  var anchorDist = !isNum(target) ? 0 : Math.abs(px - target);
  var herdSus = (wants('herd') && isNum(herd) && herd >= herdThr && exec && exec.qty > 0) ? 1 : 0;

  // Symmetric FV test (ABS distance)
  var fvFlag = wants('fv') ? (Math.abs(fvDist) > halfSpread) : false;

  var isBiased = fvFlag || herdSus === 1; // (anchor is tracked but not flipping the flag by itself here)

  return {
    is_biased: !!isBiased,
    fv_dist: fvDist || 0,
    anchor_dist: anchorDist || 0,
    herd_suscept: herdSus || 0,
    herd_thr_pct: herdThr,
    focus_active: focusSet.join(',') // for diagnostics/ED echo
  };
}


  function evHold(price, pUp, up, down) {
    pUp = isNum(pUp) ? pUp : 0.5;
    up = isNum(up) ? up : 0.02;
    down = isNum(down) ? down : -0.02;
    return pUp * (price * (1 + up)) + (1 - pUp) * (price * (1 + down)) - price;
  }
});
