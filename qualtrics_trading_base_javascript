// Hide Next (we advance programmatically)
Qualtrics.SurveyEngine.addOnload(function(){ try{ this.hideNextButton(); }catch(e){} });

Qualtrics.SurveyEngine.addOnReady(function () {
  var q = this;

  // ===== LM column index map (only for scenario fields; NOT used for treatment) =====
  var LM_INDEX = {
    scenario_id:1, scenario_name:2, symbol:3, prices_json:4,
    bid:5, ask:6, last:7, pos_qty:8, pos_px:9, hot_condition:10,
    // treatment_group is intentionally excluded from LM use
    sentiment_pct:12, session_tag:13, news_head:14, news_body:15
  };

  // ===== Unified getter for scenario fields: LM-by-name -> LM-by-index -> ED -> fallback =====
  function GV(name, fallback){
    // Never read treatment_group from LM; only ED (handled below)
    if (name === "treatment_group") {
      var edOnly = "${e://Field/treatment_group}";
      return (edOnly !== "" && edOnly !== "treatment_group") ? edOnly : fallback;
    }

    // LM by name
    var lmNamed = "${lm://Field/"+name+"}";
    if (lmNamed !== "" && lmNamed !== ("lm://Field/"+name)) return lmNamed;

    // LM by index (handles hidden characters in header names)
    var idx = LM_INDEX[name];
    if (idx){
      var lmIdx = "${lm://Field/"+idx+"}";
      if (lmIdx !== "" && lmIdx !== ("lm://Field/"+idx)) return lmIdx;
    }

    // ED fallback (useful if you mirror some scenario fields into ED upstream)
    var ed = "${e://Field/"+name+"}";
    if (ed !== "" && ed !== name) return ed;

    // Final fallback
    return fallback;
  }

  // ===== treatment comes ONLY from Embedded Data (Randomizer) =====
  function cleanAlpha(v){ return (v==null?"":String(v)).normalize("NFKD").toLowerCase().replace(/[^a-z]/g,""); }
  var ED_TREAT = "${e://Field/treatment_group}";
  // Optional force for testing: ?nudge=1 in URL OR ED debug_force_nudge=1 in Survey Flow
  var FORCE_NUDGE = /[?&]nudge=1(&|$)/.test(location.search) || ("${e://Field/debug_force_nudge}" === "1");
  var TREAT = (cleanAlpha(ED_TREAT) === "nudge") || FORCE_NUDGE;
  // One-line debug
  console.log("TREATMENT →", { ed: ED_TREAT, force: FORCE_NUDGE, treat: TREAT });

  // ===== 1) Load scenario values =====
  var symbol   = GV("symbol","ALFA");
  var prices   = [];
  try { prices = JSON.parse(GV("prices_json","[62.10,62.18,62.22,62.25,62.28,62.24,62.19,62.12,62.05,61.98,61.95,61.99,62.03,62.07,62.10,62.12]")); }
  catch(e){ prices=[62.1,62.18,62.22,62.25,62.28,62.24,62.19,62.12,62.05,61.98,61.95,61.99,62.03,62.07,62.10,62.12]; }

  var bid0     = parseFloat(GV("bid","61.80"));
  var ask0     = parseFloat(GV("ask","62.20"));
  var last0    = parseFloat(GV("last","62.10"));
  var balance  = parseFloat(GV("balance","100000"));       // carried via ED in Survey Flow
  var posQty   = parseInt(GV("pos_qty","0"),10);
  var posPx    = GV("pos_px","—");

  var hot      = GV("hot_condition","0")==="1";
  var treat    = TREAT; // <- use ED-only determination

  var herding  = parseInt(GV("sentiment_pct","76"),10);    // S1 default 76
  var session  = GV("session_tag","Regular");
  var newsHead = GV("news_head","TopBroker raises ALFA target to $75; cites outsized AI demand");
  var newsBody = GV("news_body","Analyst reiterates Buy, notes momentum in core segment. Implied daily move ±10%.");
  var newsImg  = GV("news_img","https://images.unsplash.com/photo-1551808525-51a94da548ce?q=80&w=400&auto=format&fit=crop");
  var anchor   = GV("anchor_target","75.0");
  var fairVal  = GV("fair_value","61.90");
  var pUp      = parseFloat(GV("p_up","0.52"));
  var upRet    = parseFloat(GV("up_ret","0.08"));
  var downRet  = parseFloat(GV("down_ret","-0.06"));
  var timerSec = parseInt(GV("timer_sec","12"),10);

  // ===== Pre-fill UI =====
  jQuery("#sym").text(symbol);
  jQuery("#sessionTag").text(session);
  jQuery("#balanceTxt").text(num(balance));
  jQuery("#bid").text(num(bid0));
  jQuery("#ask").text(num(ask0));
  jQuery("#last").text(num(last0));
  jQuery("#posQty").text(posQty);
  jQuery("#posPx").text(posPx);
  jQuery("#sentfill").css("width", herding+"%");
  jQuery("#sentPct").text(herding);
  jQuery("#newsHead").text(newsHead);
  jQuery("#newsBody").text(newsBody);
  jQuery("#newsImg").attr("src", newsImg);
  jQuery("#target").val(anchor);
  jQuery("#fv").val(fairVal);

  // Defaults to induce status quo
  jQuery("#ordType").val(GV("default_order","Market"));
  jQuery("#qty").val(GV("default_qty","200"));

  // ===== 2) Sparkline animation =====
  var c = document.getElementById("px"), ctx = c.getContext("2d");
  var w = c.width, h = c.height, pad = 8, i = 1;

  function draw(n){
    ctx.clearRect(0,0,w,h);
    var slice = prices.slice(0, Math.max(2,n));
    var minP = Math.min.apply(null, slice), maxP = Math.max.apply(null, slice);
    var range = (maxP - minP) || 1e-6;

    ctx.lineWidth = 1; ctx.strokeStyle = "#e5e7eb";
    ctx.beginPath(); ctx.moveTo(pad, h - pad); ctx.lineTo(w - pad, h - pad); ctx.stroke();

    ctx.lineWidth = 2; ctx.strokeStyle = "#111827"; ctx.beginPath();
    for (var k=0; k<slice.length; k++){
      var x = pad + (k*(w-2*pad)/(slice.length-1));
      var y = pad + (h-2*pad)*(1 - (slice[k]-minP)/range);
      (k===0) ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    }
    ctx.stroke();

    var last = slice[slice.length-1];
    jQuery("#last").text(num(last));
  }
  draw(i);
  var chartTimer = setInterval(function(){ i++; if(i>prices.length){clearInterval(chartTimer);} else { draw(i); } }, 450);

  // ===== 3) Timer (hot rounds) =====
  var t0 = Date.now();
  if(hot){
    var t = timerSec;
    jQuery("#timer").text(t);
    var intv = setInterval(function(){
      t--; jQuery("#timer").text(t);
      if(t<=0){ clearInterval(intv); autoSubmit("timeout"); }
    },1000);
  } else {
    jQuery("#timer").text("—");
  }

  // ===== 4) Order placement + two-step confirm with nudge =====
  var placed = false, hinted = false, exec = null;

  jQuery("#place").on("click", function(e){
    e.preventDefault();
    try {
      var ordType = jQuery("#ordType").val();
      var ordPx   = parseFloat(jQuery("#ordPx").val());
      var qty     = parseInt(jQuery("#qty").val(),10)||0;
      var useSL   = jQuery("#sl").is(":checked") ? 1 : 0;
      var useTP   = jQuery("#tp").is(":checked") ? 1 : 0;

      if(!qty || qty<1){ alert("Enter a valid quantity."); return; }
      if((ordType!=="Market") && (isNaN(ordPx))){ alert("Enter a valid price for Limit/Stop."); return; }

      var fillPx = last(); // default
      var filled = 0;

      if(ordType==="Market"){
        fillPx = ask0; filled = qty;
      } else if (ordType==="Limit"){
        if(!isNaN(ordPx) && ordPx>=ask0){ fillPx = ordPx; filled = qty; }
        else { fillPx = ordPx||ask0; filled = Math.floor(qty*Math.max(0, (ordPx||0)/ask0)); }
      } else if (ordType==="Stop"){
        if(!isNaN(ordPx) && last()>=ordPx){ fillPx = last(); filled = qty; } else { filled = 0; }
      }

      var cost = filled * fillPx;
      var delta = -cost;                 
      var newBal = balance + delta;
      flashBalance(newBal, delta);
      balance = newBal;

      exec = { ordType, ordPx:isNaN(ordPx)?null:ordPx, qty, filled, fillPx, useSL, useTP, cash_delta: delta, ts: Date.now() };

      if(treat && !hinted){
        hinted = true;
        jQuery("#hint").html(nudgeText(exec, fairVal, anchor, herding, hot)).show();
        jQuery("#confirm").show();
        jQuery("#place").text("Adjust Order").removeClass("btn-primary").addClass("btn-ghost");
      } else {
        jQuery("#confirm").show();
      }

      placed = true;
    } catch(err){
      console.error("Error in Place handler:", err);
      jQuery("#confirm").show();
      placed = true;
    }
  });

  jQuery("#confirm").on("click", function(e){
    e.preventDefault();
    if(!placed){ return; }
    submitAndAdvance("ok");
  });

  // ===== 5) Helpers =====
  function last(){ 
    var idx = Math.min(i-1, prices.length-1);
    return prices[idx] || last0; 
  }
  function num(x){ 
    var n = parseFloat(x);
    if(isNaN(n)) return x;
    return n.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2});
  }
  function flashBalance(newBal, delta){
    jQuery("#balanceTxt").text(num(newBal));
    var cls = delta>=0 ? "flash-up" : "flash-down";
    jQuery(".bal").addClass(cls);
    setTimeout(function(){ jQuery(".bal").removeClass(cls); }, 600);
  }
  function nudgeText(exec, fv, anchor, herd, hot){
    var fvNum = parseFloat(fv);
    var dist = (exec.ordType==="Market") ? (ask0 - fvNum) : ((exec.ordPx||ask0) - fvNum);
    var msg = [];
    msg.push(`<b>Quick check</b>: Your ${exec.ordType} entry is ${dist>=0?'+':''}${dist.toFixed(2)} vs fair value ${fvNum.toFixed(2)}.`);
    msg.push(`Spread is ${(ask0-bid0).toFixed(2)}. Consider execution cost vs expected move.`);
    if(anchor) msg.push(`Don't over-weight the target ${anchor} (possible <i>anchor</i>).`);
    if(herd>=70) msg.push(`High “others buying” signal (${herd}%) can trigger <i>herding</i> bias.`);
    if(hot) msg.push(`Timer pressure can increase <i>hot</i> decisions—take a breath.`);
    return msg.join("<br>");
  }
  function computeUnrealizedPnl(qty, px){
    if(!qty || !px || px==="—") return "—";
    var u = qty * (last() - parseFloat(px));
    var el = jQuery("#unrl");
    el.text((u>=0?"+":"") + num(u));
    el.toggleClass("success", u>0).toggleClass("danger", u<0);
    return u;
  }

  computeUnrealizedPnl(posQty, posPx);

  // ===== 6) Robust advance helper =====
  function advance(){
    try { q.clickNextButton(); } catch(e) {}

    setTimeout(function(){
      jQuery("#NextButton, input[name='NextButton'], button[id*='Next'], button[name*='Next'], [class*='Next']")
        .prop("disabled", false).trigger("click");
    }, 60);

    setTimeout(function(){
      try { Qualtrics.SurveyEngine.navClick && Qualtrics.SurveyEngine.navClick("NextButton"); } catch(e){}
    }, 120);

    setTimeout(function(){
      try { jQuery("form").first().trigger("submit"); } catch(e){}
    }, 180);
  }

  // ===== 7) Save data & advance =====
  function submitAndAdvance(reason){
    try {
      var rt = Date.now() - t0;
      var fv = parseFloat(jQuery("#fv").val());
      var target = parseFloat(jQuery("#target").val());
      var biasMetrics = deriveBias(exec, fv, target, herding);

      Qualtrics.SurveyEngine.setEmbeddedData("rt_ms", rt);
      Qualtrics.SurveyEngine.setEmbeddedData("hint_shown", hinted ? "1" : "0");
      Qualtrics.SurveyEngine.setEmbeddedData("exec_ordType", exec && exec.ordType);
      Qualtrics.SurveyEngine.setEmbeddedData("exec_ordPx", exec && exec.ordPx);
      Qualtrics.SurveyEngine.setEmbeddedData("exec_qty", exec && exec.qty);
      Qualtrics.SurveyEngine.setEmbeddedData("exec_filled", exec && exec.filled);
      Qualtrics.SurveyEngine.setEmbeddedData("exec_fillPx", exec && exec.fillPx);
      Qualtrics.SurveyEngine.setEmbeddedData("cash_delta", exec && exec.cash_delta);
      Qualtrics.SurveyEngine.setEmbeddedData("new_balance", balance);
      Qualtrics.SurveyEngine.setEmbeddedData("autosubmit_reason", reason || "");
      Qualtrics.SurveyEngine.setEmbeddedData("bias_is_biased", biasMetrics.is_biased ? "1" : "0");
      Qualtrics.SurveyEngine.setEmbeddedData("bias_anchor_dist", biasMetrics.anchor_dist.toFixed(4));
      Qualtrics.SurveyEngine.setEmbeddedData("bias_fv_dist", biasMetrics.fv_dist.toFixed(4));
      Qualtrics.SurveyEngine.setEmbeddedData("bias_herd_suscept", biasMetrics.herd_suscept.toFixed(4));
      Qualtrics.SurveyEngine.setEmbeddedData("ev_hold", evHold(last(), pUp, upRet, downRet).toFixed(6));
      Qualtrics.SurveyEngine.setEmbeddedData("balance", balance);
    } catch(err){
      console.error("Error during submitAndAdvance:", err);
    }

    advance();
    setTimeout(advance, 400); // last-resort nudge forward
  }

  function deriveBias(exec, fv, target, herd){
    var px = (exec && exec.ordType==="Market") ? ask0 : ((exec && exec.ordPx==null) ? ask0 : (exec ? exec.ordPx : ask0));
    var fvDist = px - fv;
    var anchorDist = (isNaN(target) || target==null) ? 0 : Math.abs(px - target);
    var herdSus = (herd>=70 && exec && exec.qty>0) ? 1 : 0;
    var isBiased = (fvDist > (ask0-bid0)/2) || (herdSus===1);
    return { is_biased: !!isBiased, fv_dist: fvDist||0, anchor_dist: anchorDist||0, herd_suscept: herdSus||0 };
  }

  function evHold(price, pUp, up, down){
    return pUp*(price*(1+up)) + (1-pUp)*(price*(1+down)) - price;
  }
});
